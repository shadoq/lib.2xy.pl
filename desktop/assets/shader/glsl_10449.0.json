{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_10449.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// Mountains. (C) David Hoskins - 2013\n// https://www.shadertoy.com/view/4slGD4\n// A ray-marched version of my terrain renderer which uses\n// streaming texture normals for speed:-\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\n\n// It uses binary subdivision to accurately find the height map.\n// Lots of thanks to Inigo and his noise functions!\n\n// Video of my OpenGL version that \n// http://www.youtube.com/watch?v=qzkBnCBpQAM\n\n// Stereo version code thanks to Croqueteer :)\n//#define STEREO \n\n// Take out the trees by removing the following line: \n#define TREES\n\n#ifdef TREES\nfloat treeLine = 0.0;\nfloat treeCol = 0.0;\n#endif\n\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\nvec3 sunColour = vec3(1.0, .9, .83);\nfloat specular = 0.0;\nvec3 cameraPos;\n\n// This peturbs the fractal positions for each iteration down...\n// Helps make nice twisted landscapes...\nconst mat2 rotate2D = mat2(1.4623, 1.67231, -1.67231, 1.4623);\n\n// Alternative rotation:-\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\n\n//--------------------------------------------------------------------------\n// Noise functions...\nfloat Hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n//--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n//--------------------------------------------------------------------------\nvec2 Noise2( in vec2 x )\n{\n    vec2 res = vec2(Noise(x), Noise(x+vec2(4101.03, 2310.0)));\n    return res-vec2(.5, .5);\n}\n\n//--------------------------------------------------------------------------\n// iq's derivative noise function...\nvec3 NoiseDerivative( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float a = Hash(n+  0.0);\n    float b = Hash(n+  1.0);\n    float c = Hash(n+ 57.0);\n    float d = Hash(n+ 58.0);\n    return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n                30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n//--------------------------------------------------------------------------\n#ifdef TREES\nfloat Trees(vec2 p)\n{\n    p *= 5.0;\n    vec2 rnd = Noise2(p);//vec2(Hash(floor(p.x*4.0)), Hash(floor(p.y*4.0)))*.5;\n    vec2 v2 = fract(p+rnd)-.5;\n    return max(.5-(length(v2)), 0.0) * treeLine*.6;\n}\n#endif\n\n//--------------------------------------------------------------------------\n// Low def version for ray-marching through the height field...\nfloat Terrain( in vec2 p)\n{\n    vec2 pos = p*0.08;\n    float w = (Noise(pos*.25)*0.75+.15);\n    w = 36.0 * w * w;\n    vec2 dxy = vec2(0.0, 0.0);\n    float f = .0;\n    for (int i = 0; i < 5; i++)\n    {\n        vec3 v = NoiseDerivative(pos);\n        dxy += v.yz;\n        f += (w * (v.x) / (1.0 + dot(dxy, dxy))) ;\n        w = -w * 0.37;  //...Flip negative and positive for variation\n        pos = rotate2D * pos;\n    }\n    float ff = Noise(pos*.003);\n    \n    f += pow(ff, 6.0)*85.-1.0;\n    return f;\n}\n\n//--------------------------------------------------------------------------\n// Map to lower resolution for height field mapping for Scene function...\nfloat Map(in vec3 p)\n{\n    float h = Terrain(p.xz);\n        \n    #ifdef TREES\n    float ff = Noise(p.xz*1.3)*.8;\n    treeLine = smoothstep(ff, .1+ff, h) * smoothstep(.5+ff, .4+ff, h);\n    treeCol = Trees(p.xz);\n    h += treeCol;\n    #endif\n    \n    return p.y - h;\n}\n\n//--------------------------------------------------------------------------\n// High def version only used for grabbing normal information.\nfloat Terrain2( in vec2 p)\n{\n    // There's some real magic numbers in here! \n    // The Noise calls add large mountain ranges for more variation over distances...\n    vec2 pos = p*0.08;\n    float w = (Noise(pos*.25)*0.75+.15);\n    w = 36.0 * w * w;\n    vec2 dxy = vec2(0.0, 0.0);\n    float f = .0;\n    for (int i = 0; i < 5; i++)\n    {\n        vec3 v = NoiseDerivative(pos);\n        dxy += v.yz;\n        f += (w * (v.x)  / (1.0 + dot(dxy, dxy)));\n        w =  - w * 0.37;    //...Flip negative and positive for varition       \n        pos = rotate2D * pos;\n    }\n    float ff = Noise(pos*.003);\n    f += pow(ff, 6.0)*85.-1.0;\n    \n    #ifdef TREES\n    treeCol = Trees(p);\n    f += treeCol;\n    if (treeCol > 0.0) return f;\n    #endif\n    \n    // That's the last of the low resolution, now go down further for the Normal data...\n    for (int i = 0; i < 6; i++)\n    {\n        vec3 v = NoiseDerivative(pos);\n        dxy += v.yz;\n        f += (w * (v.x) / (1.0 + dot(dxy, dxy)));\n        w =  - w * 0.37;\n        pos = rotate2D * pos;\n    }\n    \n    \n    return f;\n}\n\n//--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n    float w = .65;\n    float f = 0.0;\n\n    for (int i = 0; i < 4; i++)\n    {\n        f += Noise(xy) * w;\n        w *= 0.5;\n        xy *= 2.3;\n    }\n    return f;\n}\n\n//--------------------------------------------------------------------------\n// Simply Perlin clouds that fade to the horizon...\n// 200 units above the ground...\nvec3 GetClouds(in vec3 sky, in vec3 rd)\n{\n    if (rd.y < 0.0) return sky;\n    float v = (200.0-cameraPos.y)/rd.y;\n    rd.xz *= v;\n    rd.xz += cameraPos.xz;\n    rd.xz *= .010;\n    float f = (FractalNoise(rd.xz) -.55) * 5.0;\n    // Uses the ray's y component for horizon fade of fixed colour clouds...\n    sky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\n\n    return sky;\n}\n\n\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n    float sunAmount = max( dot( rd, sunLight), 0.0 );\n    float v = pow(1.0-max(rd.y,0.0),5.)*.5;\n    vec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\n    // Wide glare effect...\n    sky = sky + sunColour * pow(sunAmount, 6.5)*.32;\n    // Actual sun...\n    sky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\n    return sky;\n}\n\n//--------------------------------------------------------------------------\n// Merge mountains into te sky background for correct disappearance...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n    float fogAmount = clamp(dis* 0.0000165, 0.0, 1.0);\n    return mix( rgb, GetSky(dir), fogAmount );\n}\n\n//--------------------------------------------------------------------------\n// Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n    float h = dot(sunLight,normal);\n    float c = max(h, 0.0)+.1;\n    mat = mat * sunColour * c ;\n    // Specular...\n    if (h > 0.0)\n    {\n        vec3 R = reflect(sunLight, normal);\n        float specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\n        mat = mix(mat, sunColour, specAmount);\n    }\n}\n\n//--------------------------------------------------------------------------\n// Hack the height, position, and normal data to create the coloured landscape\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\n{\n    vec3 mat;\n    specular = .0;\n    vec3 dir = normalize(pos-cameraPos);\n    \n    vec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\n\n    float disSqrd = dis * dis;// Squaring it gives better distance scales.\n\n    float f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\n    f += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\n    f *= .55;\n    vec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\n    mat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\n    // Should have used smoothstep to add colours, but left it using 'if' for sanity...\n    if (normal.y < .5)\n    {\n        float v = normal.y;\n        float c = (.5-normal.y) * 4.0;\n        c = clamp(c*c, 0.1, 1.0);\n        f = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\n        f += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\n        mat = mix(mat, vec3(.4*f), c);\n        specular+=.1;\n    }\n\n    // Grass. Use the normal to decide when to plonk grass down...\n    if (matPos.y < 45.35 && normal.y > .65)\n    {\n\n        m = vec3(Noise(matPos.xz*.073)*.5+.15, Noise(matPos.xz*.12)*.6+.25, 0.0);\n        m *= (normal.y- 0.75)*.85;\n        mat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\n    }\n    #ifdef TREES\n    if (treeCol > 0.0)\n    {\n        mat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\n        normal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\n        specular = .0;\n    }\n    #endif\n    \n    // Snow topped mountains...\n    if (matPos.y > 50.0 && normal.y > .28)\n    {\n        float snow = clamp((matPos.y - 50.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\n        mat = mix(mat, vec3(.7,.7,.8), snow);\n        specular += snow;\n    }\n    // Beach effect...\n    if (matPos.y < 1.45)\n    {\n        if (normal.y > .4)\n        {\n            f = Noise(matPos.xz * .084)*1.5;\n            f = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\n            float t = (normal.y-.4);\n            t = (t*t);\n            mat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\n        }\n        // Cheap under water darkening...it's wet after all...\n        if (matPos.y < 0.0)\n        {\n            mat *= .5;\n        }\n    }\n\n    DoLighting(mat, pos, normal,dir, disSqrd);\n    \n    // Do the water...\n    if (cameraPos.y < 0.0)\n    {\n        // Can go under water, but current camera doesn't find a place...\n        mat = mix(mat, vec3(0.0, .1, .2), .75); \n    }else\n    if (matPos.y < 0.0)\n    {\n        // Pull back along the ray direction to get water surface point at y = 0.0 ...\n        float localtime = (iTime)*.03;\n        vec3 watPos = matPos;\n        watPos += -dir * (watPos.y/dir.y);\n        // Make some dodgy waves...\n        float tx = cos(watPos.x*.052) *4.5;\n        float tz = sin(watPos.z*.072) *4.5;\n        vec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+localtime*35.0-tx));\n        co += Noise2(vec2(watPos.z*8.6+localtime*13.0-tx, watPos.x*8.712+tz))*.4;\n        vec3 nor = normalize(vec3(co.x, 20.0, co.y));\n        nor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\n        // Mix it in at depth transparancy to give beach cues..\n        mat = mix(mat, GetClouds(GetSky(nor), nor), clamp((watPos.y-matPos.y)*1.1, .4, .66));\n        // Add some extra water glint...\n        float sunAmount = max( dot(nor, sunLight), 0.0 );\n        mat = mat + sunColour * pow(sunAmount, 228.5)*.6;\n    }\n    mat = ApplyFog(mat, disSqrd, dir);\n    return mat;\n}\n\n//--------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n    // Home in on the surface by dividing by two and split...\n    for (int n = 0; n < 4; n++)\n    {\n        float halfwayT = (oldT + t ) * .5;\n        vec3 p = rO + halfwayT*rD;\n        if (Map(p) < 0.25)\n        {\n            t = halfwayT;\n        }else\n        {\n            oldT = halfwayT;\n        }\n    }\n    return t;\n}\n\n//--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, out float resT )\n{\n    float t = 1.2;\n    float oldT = 0.0;\n    float delta = 0.0;\n    for( int j=0; j<170; j++ )\n    {\n        if (t > 240.0) return false; // ...Too far\n        vec3 p = rO + t*rD;\n        if (p.y > 95.0) return false; // ...Over highest mountain\n\n        float h = Map(p); // ...Get this positions height mapping.\n        // Are we inside, and close enough to fudge a hit?...\n        if( h < 0.25)\n        {\n            // Yes! So home in on height map...\n            resT = BinarySubdivision(rO, rD, t, oldT);\n            return true;\n        }\n        // Delta ray advance - a fudge between the height returned\n        // and the distance already travelled.\n        // It's a really fiddly compromise between speed and accuracy\n        // Too large a step and the tops of ridges get missed.\n        delta = max(0.01, 0.2*h) + (t*0.0065);\n        oldT = t;\n        t += delta;\n    }\n\n    return false;\n}\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    float m = 1.0*300.0;\n    t = (iTime*1.5+m+350.)*.006 + t;\n    vec2 p = 376.0*vec2( sin(3.5*t), cos(1.5*t) );\n    return vec3(140.0-p.x, 0.6, -88.0+p.y);\n}\n\n//--------------------------------------------------------------------------\n// Some would say, most of the magic is done in post! :D\nvec3 PostEffects(vec3 rgb, vec2 uv)\n{\n    // Gamma first...\n    rgb = pow(rgb, vec3(0.45));\n    #define CONTRAST 1.2\n    #define SATURATION 1.12\n    #define BRIGHTNESS 1.14\n    rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n    rgb = clamp(rgb+Hash(rgb.rb+uv)*.05, 0.0, 1.0);\n    return rgb;\n}\n\n//--------------------------------------------------------------------------\nvoid main(void)\n{\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy / iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\n    vec3 camTar;\n\n    #ifdef STEREO\n    float isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\n    #endif\n\n    // Use several forward heights, of decreasing influence with distance from the camera.\n    float h = 0.0;\n    float f = 1.0;\n    for (int i = 0; i < 7; i++)\n    {\n        h += Terrain(CameraPath((1.0-f)*.004).xz) * f;\n        f -= .1;\n    }\n    cameraPos.xz = CameraPath(0.0).xz;\n    camTar.xz    = CameraPath(.005).xz;\n    camTar.y = cameraPos.y = (h*.23)+3.5;\n    \n    float roll = 0.15*sin(iTime*.2);\n    vec3 cw = normalize(camTar-cameraPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    vec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\n\n    #ifdef STEREO\n    cameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\n    #endif\n\n    vec3 col;\n    float distance;\n    if( !Scene(cameraPos,rd, distance) )\n    {\n        // Missed scene, now just get the sky value...\n        col = GetSky(rd);\n        col = GetClouds(col, rd);\n    }\n    else\n    {\n        // Get world coordinate of landscape...\n        vec3 pos = cameraPos + distance * rd;\n        // Get normal from sampling the high definition height map\n        // Use the distance to sample larger gaps to help stop aliasing...\n        float p = min(.3, .0005+.00001 * distance*distance);\n        vec3 nor    = vec3(0.0,         Terrain2(pos.xz), 0.0);\n        vec3 v2     = nor-vec3(p,       Terrain2(pos.xz+vec2(p,0.0)), 0.0);\n        vec3 v3     = nor-vec3(0.0,     Terrain2(pos.xz+vec2(0.0,-p)), -p);\n        nor = cross(v2, v3);\n        nor = normalize(nor);\n\n        // Get the colour using all available data...\n        col = TerrainColour(pos, nor, distance);\n    }\n\n    col = PostEffects(col, uv);\n    \n    #ifdef STEREO   \n    col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );  \n    #endif\n    \n    gl_FragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------\n\n"}