{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_25191.1,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"#ifdef GL_ES\n//precision mediump float;\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n// IT's strange, the version http://glslsandbox.com/e#25099.7\n// does not compile on my (cheap) desktop computer (without any error line)\n// but is ok on my old laptop...\n//\n// It looks like using a vec2 ( material , dist ) for the raymarching \n// is failing somewhere...\n//\n// Do you know why ?\n\n\n#define NB_ITER 256\n#define FAR     100.\n\n\n//#define EDIT\n\nvec3 skyColor( vec2 uv)\n{\n    vec3 col1 = vec3(.0, .4, .6);\n    vec3 col2  = vec3(.6, .6,.4);\n    return mix (col1, col2, 1.-length(uv+vec2(.2, .3) ) / .5);\n}\nvec4 mapFloor ( vec3 pos )\n{\n    vec3 col1 = vec3( 1., 0., 0.);\n    vec3 col2 = vec3( 0., 1., 0.);\n    float val = sign( fract( .25*pos.x) -.5 ) * sign( fract( .25*pos.z) -.5 );\n    vec3 col =mix( col1, col2, val );\n    float dist = pos.y;\n    return vec4( col, dist );\n}\n\nvec4 mapSphere( vec3 pos, float radius )\n{\n//  float DEP_VAL =sin(time) +2.;\n    float dist = length(  pos ) - radius;//+ .2*sin(DEP_VAL *pos.x + sin(5.*time)) * sin(DEP_VAL *pos.y+ cos(6.*time)) * sin(DEP_VAL *pos.z+ sin(time));\n    vec3 col = vec3( 1.0, .2, .2 );\n    return  vec4( col, dist);\n}\n\n\nfloat Mylength( vec3 pos )\n{\n    return max(abs(pos.x), max( abs(pos.y), abs( pos.z)) );\n}\n\nfloat Mylength2( vec3 pos )\n{\n    return abs(pos.x) + abs(pos.y) + abs( pos.z);\n}\n\nvec4 mapCube( vec3 pos )\n{\n    //vec4 ret = vec4( abs(atan (pos.x ) ) *abs(atan (pos.y ) ), .0, .0, 1.  );\n    //vec4 ret = vec4(fract( pos.z ) > .5);\n    vec3 col = vec3( .0, .9, .1);\n    float dist = Mylength(  pos ) - 5.0;\n    return vec4( col, dist );\n}\n\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\n\nvec4 subst( vec4 val1, vec4 val2 )\n{\n    float dist = max(-val2.w, val1.w);\n    return vec4(vec3(val1), dist);\n}\n\n\nvec4 mapLotsOfSpheres( vec3 pos)\n{\n    vec3 col = vec3(.3, .8, .2 );\n    const float radius=6.0;\n    float dist = length( mod( pos+15., 30.)-15.) -radius;\n    return vec4( col, dist);\n}\nvec4 mapLotsOfCubes( vec3 pos)\n{\n    vec3 col = vec3(.3, .8, .2 );\n    const float radius=6.0;\n    float dist = Mylength( mod( pos+8., 16.)-8.) -radius;\n    return vec4( col, dist);\n}\n\nvec4 StrangeSphere( vec3 pos ) \n{\n    //float move = sin(3.*time ) *.5 - 10.;\n    float move = 10.;\n    float rad = 10.;\n    vec3 newPos = pos - vec3( .0+move, 5., 50.);\n    vec4 val2 = mapSphere(newPos, rad );\n    vec3 p = newPos;\n    float magicVal = 6. + 3.9*sin(.5*time);\n    //float magicVal = 2.5;\n    float fact = .45;\n    if (val2.w < .1 )   // Optimization, don't try the strange thing outside the sphere\n    for (int i = 0; i < 6; i++)\n    {\n        float t = float(i)*.11+0.004*time;\n        float c = cos(t);\n        float s = sin(t);\n        mat2 m = mat2(c,-s,s,c);\n        p.xy = m*p.xy;\n                  \n        rad *= fact;\n        p.x = p.x - rad*2.;\n        vec3 p2 = p;\n        p2.xzy=mod (p.xzy+rad, rad*magicVal) -rad;\n        //p2.z=mod (p.z+rad, rad*2.5) -rad;\n        //p2=mod (p+rad, rad*2.5) -rad;\n\n        //vec3 p2 = p;\n        vec4 sph = mapSphere( p2, rad );\n        //val2= combine(val2, sph);\n        val2 = subst(val2, sph);\n        //val2 = sph;\n    }\n    return val2;\n}\n\n\n//#define MOVING_OBJECTS\nvec4 map( vec3 pos)\n{\n    vec4 ret = mapFloor( pos );\n\n    vec4 res = combine( ret, StrangeSphere(pos));\n    return res;\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 norm)\n{\n    const int steps = 3;\n    const float delta = 0.50;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(pos + norm*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 15; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t).w;\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n//#define EDIT\nvoid main( void ) {\n#ifdef EDIT\n    gl_FragColor = vec4( .1);\n#else\n    vec2 uv = ( gl_FragCoord.xy / iResolution.xy );\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv.x += cos( uv.x)*3.02;\n    //float fish_eye =  -length(uv)*1.+ sin(time);\n    //float fish_eye = sin(5.*uv.x) + sin(5.*uv.y) + 1.;\n    float fish_eye =  1.;\n    vec3 dir = vec3( uv, 1.0 + fish_eye);\n    dir = normalize(dir);\n    \n    vec3 pos = vec3( .0+3.*mouse.x, 8.1, .0+3.*mouse.y);\n    //vec3 pos = vec3( 20.*sin(time), 8.1, 20.*cos(time));\n    \n    float nbIterF = 0.;\n    vec4 result;\n    for (int i =0; i < NB_ITER; i++)\n    {\n        result = map( pos );\n        pos += result.w * dir;\n        if ( (pos.z > FAR) || (abs(result.w) < .001)) break;\n        //if ( (pos.z > FAR)) break;\n        nbIterF += 1.0; \n    }\n    vec3 col = result.xyz;\n    if ( pos.z> FAR ) \n    {\n        col = skyColor(uv);\n    }\n    else\n    {\n        //vec3 lightPos = vec3(10.* sin(3.*iTime) + 10., 8.5, 10.*cos(3.*iTime) + 30. );\n        vec3 lightPos = vec3(1.* sin(3.*iTime) + 10., 8.5, 1.*cos(3.*iTime) + 30. );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .0, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n                   result.w - map( pos - eps.yxy ).w,\n                   result.w - map( pos - eps.yyx ).w );\n        n = normalize(n);\n        //col =abs(n);\n                \n        float lambert = max(.0, dot( n, light2Pos));\n        col *= vec3(lambert);\n        \n        //vec3 light = vec3( sin( time ), 20 , cos(time) );\n        //col = col* vec3(dot ( -dir, n ));\n        \n        // specular : \n        vec3 h = normalize( -dir + light2Pos);\n        float spec = max( 0., dot( n, h ) );\n        col += vec3(pow( spec, 16.));\n        col *= ambientOcclusion( pos, n );\n        col *= softshadow(pos, light2Pos, .02, 5., 14. );\n        //col = vec3(ambientOcclusion( pos, n ));\n        \n    }\n    //vec3 col = vec3( nbIterF/64. );\n    gl_FragColor= vec4( col, 1.0);\n#endif\n}\n"}