{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_2012.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// Ray Marching (Sphere Tracing) experiment by Riccardo Gerosa aka h3r3 \n// Blog: http://www.postronic.org/h3/ G+: https://plus.google.com/u/0/117369239966730363327 Twitter: http://twitter.com/#!/h3r3\n// This GLSL shader is based on the awesome work of JC Hart and I Quilez. Features two lights with soft shadows, blobby objects, object space ambient occlusion.\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nconst float PI = 3.14159;\nconst int MAX_RAYMARCH_ITER = 50;\nconst float MIN_RAYMARCH_DELTA = 0.0015;\nconst float GRADIENT_DELTA = 0.002;\nconst float SOFT_SHADOWS_FACTOR = 3.0;\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdPlane(vec3 p, vec4 n) { // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat blend(float d1, float d2) {\n    float dd = cos((d1 - d2) * PI);\n    return mix(d1, d2, dd);\n}\n\nfloat map(vec3 p, vec3 ray_dir) { //  ray_dir is used only for some optimizations\n    float plane = sdPlane(p + vec3(0,0.3,0), vec4(normalize(vec3(0, 1, -0.5)),0));\n    if (ray_dir.z <= 0.0 || p.z < 1.0) { // Optimization: try not to compute blobby object distance when possible\n        float sphere1 = sdSphere(p + vec3(cos(time * 0.2 + PI) * 0.45,0,0), 0.25);\n        float sphere2 = sdSphere(p + vec3(cos(time * 0.2) * 0.45,0,0), 0.25);\n        float torus = sdTorus(vec3(p.y + sin(time) *0.1, p.z + cos(time) * 0.1, p.x), vec2(0.2, 0.08));\n        return min(min(blend(sphere1, torus), blend(sphere2, torus)), plane);\n    } else {\n        return plane;\n    }\n}\n\nfloat map(vec3 p) {\n    return map(p, vec3(0,0,0));\n}\n\nvec3 gradientNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(GRADIENT_DELTA, 0, 0)) - map(p - vec3(GRADIENT_DELTA, 0, 0)),\n        map(p + vec3(0, GRADIENT_DELTA, 0)) - map(p - vec3(0, GRADIENT_DELTA, 0)),\n        map(p + vec3(0, 0, GRADIENT_DELTA)) - map(p - vec3(0, 0, GRADIENT_DELTA))));\n}\n\nbool raymarch(vec3 ray_start, vec3 ray_dir, out float dist, out vec3 p, out int iterations) {\n    dist = 0.0;\n    float minStep = 0.0001;\n    for (int i = 1; i <= MAX_RAYMARCH_ITER; i++) {\n        p = ray_start + ray_dir * dist;\n        float mapDist = map(p, ray_dir);\n        if (mapDist < MIN_RAYMARCH_DELTA) {\n           iterations = i;\n           return true;\n        }\n        if(mapDist < minStep) { mapDist = minStep; }\n        dist += mapDist;\n        float ifloat = float(i);\n        minStep += 0.0000018 * ifloat * ifloat;\n    }\n    return false;\n}\n\nbool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, out float dist, out vec3 p, out int iterations, out float light_intensity) {\n    dist = 0.0;\n    float minStep = 0.0001;\n    light_intensity = 1.0;\n    for (int i = 1; i <= MAX_RAYMARCH_ITER; i++) {\n        p = ray_start + ray_dir * dist;\n        float mapDist = map(p, ray_dir);\n        if (mapDist < MIN_RAYMARCH_DELTA) {\n            iterations = i;\n            return true;\n        }\n        light_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist);\n        if(mapDist < minStep) { mapDist = minStep; }\n        dist += mapDist;\n        if (dist >= maxDist) { break; }\n        float ifloat = float(i);\n        minStep += 0.0000018 * ifloat * ifloat;\n    }\n    return false;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 0.03;\n    float ao = 0.0;\n    float dist;\n    for (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n        ao += (dist - map(p + n * dist)) / float(i * i);\n    }\n    return ao;\n}\n\nvoid main( void ) {\n    vec2 position = vec2((gl_FragCoord.x - iResolution.x / 2.0) / iResolution.y, (gl_FragCoord.y - iResolution.y / 2.0) / iResolution.y);\n    vec3 ray_start = vec3(0, 0, -2);\n    vec3 ray_dir = normalize(vec3(position,0) - ray_start);\n\n    float angleX = (mouse.y -0.5) * 0.5;\n    float angleY = (mouse.x -0.5);\n    float angleZ = (mouse.x -0.5) * 0.1;\n    mat3 rotateX = mat3(1.0, 0.0, 0.0,\n                        0.0, cos(angleX), -sin(angleX),\n                        0.0, sin(angleX), cos(angleX));\n    mat3 rotateY = mat3(cos(angleY), 0.0, sin(angleY),\n                        0.0, 1.0, 0.0,\n                        -sin(angleY), 0.0, cos(angleY));\n    mat3 rotateZ = mat3(cos(angleZ), -sin(angleZ), 0.0,\n                        sin(angleZ), cos(angleZ), 0.0,\n                        0.0, 0.0, 1.0);\n    ray_dir = ray_dir * rotateX * rotateY * rotateZ;\n    ray_start.x = -mouse.x * 3.0 + 1.5;\n    ray_start.y = mouse.y * 1.0 - 0.5;\n\n    vec3 light1_pos = vec3(-0.5 + sin(iTime), 1.0, -1.0 + cos(iTime * 0.5) * 2.0);\n    vec3 light2_pos = vec3(sin(iTime * 1.9 + 2.0) * 0.6, sin(iTime * 1.8) + 5.0, -0.5 + sin(iTime * 1.6) * 0.5);\n    vec4 color;\n    float dist; vec3 p; int iterations;\n    if (raymarch(ray_start, ray_dir, dist, p, iterations)) {\n        float d2; vec3 p2; int i2; float light_intensity;\n\n        vec3 light1_dir = light1_pos - p;\n        float light1_dist = length(light1_dir);\n        light1_dir = normalize(light1_dir);\n\n        vec3 light2_dir = light2_pos - p;\n        float light2_dist = length(light2_dir);\n        light2_dir = normalize(light2_dir);\n\n        vec3 n = gradientNormal(p);\n        float ambient = (0.16 - ambientOcclusion(p, n)) / (dist * dist * 0.17);\n        vec3 diffuse1 = vec3(0,0,0);\n        if (!raymarch_to_light(p + light1_dir * 0.1, light1_dir, light1_dist, d2, p2, i2, light_intensity)) {\n            diffuse1 = vec3(1.0, 0.8, 0.6) * max(0.0, dot(normalize(light1_pos - p), n) * light_intensity * 3.0 / (dist * dist));\n        }\n        vec3 diffuse2 = vec3(0,0,0);\n        if (!raymarch_to_light(p + light2_dir * 0.1, light2_dir, light2_dist, d2, p2, i2, light_intensity)) {\n            diffuse2 = vec3(0.6, 0.8, 1.0) * max(0.0, dot(normalize(light2_pos - p), n) * light_intensity * 3.0 / (dist * dist));\n        }\n        color = vec4(vec3(0.9,0.8,0.6) * max(diffuse1 + diffuse2, ambient), 1);\n    } else {\n        color = vec4(0,0,0,0);\n    }\n    gl_FragColor = color;\n}"}