{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_5534.9,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// I am trying to understand raymarching and decided to clean up a simple example I found and gave it proper names for all the variables\n// Hope this helps someone better understand how this works.\n// countfrolic@gmail.com\n\n// Tried to make a wintry tree - Kabuto\n\n\n#define PI 3.14159\nconst float sin45deg = 0.70710678118654752440084436210485;\n\nstruct Camera                                           // A camera struct that holds all relevant camera parameters\n{\n    vec3 position;\n    vec3 lookAt;\n    vec3 rayDir;\n    vec3 forward, up, left;\n};\n\n// elements library by logos7(a.t.)o2.pl\n// see: http://logos7.pl/Anupadaka/index.html\n// http://logos7.pl/Anupadaka/sde_space_operations.php\n// http://logos7.pl/Anupadaka/sde_primitives3D.php\n// I want to create the biggest elements library - you can help me and send your own things\n// you will be credited\n    \nvec3 sopPolarRepeatY(vec3 P, float n)\n{\n    float r = length(P.xz);\n    float a = atan(P.z, P.x);\n    float c = 3.14159265358979 / n;\n\n    a = mod(a, 2.0 * c) - c;\n\n    P.x = r * cos(a);\n    P.z = r * sin(a);\n\n    return P;\n}\n\n// Optimized case for 4 repetitions\nvec3 sopPolarRepeatY4(vec3 P)\n{\n    P.xz = vec2(P.x+P.z,P.z-P.x)*sin45deg;\n    P.xz = abs(P.x) > abs(P.z) ? P.xz*sign(P.x) : vec2(P.z,-P.x)*sign(P.z);\n    return P;\n}\n\nvec3 sopRotateZ(vec3 P, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n\n    return vec3(c * P.x - s * P.y, s * P.x + c * P.y, P.z);\n}\n\nfloat sdeCylinderY(vec3 P, vec3 C, float h, float r)\n{\n    P -= C;\n\n    return max(abs(P.y) - 0.5 * h, length(P.xz) - r);\n}\n\nfloat GetDistanceToScene( vec3 P)\n{\n    P.xz = (fract(P.xz*.3+.5)-.5)/.3;\n    float d = min(sdeCylinderY(P, vec3(0.0), 1.0, 0.085), min(P.y,6.-P.y)); // ground & sky planes added\n    float s;\n    vec3 O = P;\n    float f = 1.; // remember the scaling applied to space so far\n\n    for (int i = 0; i < 5; i++)\n    {\n        O = 1.4 * O;\n        f = 1.4 * f;\n        O = sopPolarRepeatY4(O);\n\n        O = sopRotateZ(O, 0.842);\n\n        O.x -= -0.515;\n        O.y -= 1.0;\n\n        d = min(d, sdeCylinderY(O, vec3(0.0), 1.0, 0.085)/f); // Tweak: /f added. (If you scale space you should scale distances as well. This works much better than the previously used approximation.)\n    }\n\n    return d;\n}\n\nfloat traceLight(vec3 from, vec3 to, float tolerance) {\n    float len = distance(from,to);\n    vec3 dir = (to-from)/len;\n    \n    const float MIN_DISTANCE = 0.1;                             // Distance to scene that we will count as a hit\n    const int MAX_STEPS = 50;                               // Maxmimum amount of ray marching steps before counting the ray as a miss\n    \n    float distanceFromCamera = 0.0;                             // The ray starts at the camera, so 0\n    \n    vec3 raymarchPosition = from;                                   // Variable holding the current position along the camera ray\n    float distanceToScene = GetDistanceToScene(raymarchPosition);\n    \n    for(int i=0;i<MAX_STEPS;i++){\n            if (distanceToScene< MIN_DISTANCE || distanceFromCamera>len-tolerance) break;   // Exit if we hit something, or if the ray goes past MAX_DEPTH\n        \n        distanceFromCamera += distanceToScene;                      // If we didn't exit, move away from the camera...\n            raymarchPosition = from+dir*distanceFromCamera;         // Calculate new position along the camera ray\n        distanceToScene = GetDistanceToScene(raymarchPosition);             // Check how far the new position is away from the scene\n    }\n    return step(len-tolerance, distanceFromCamera);\n}\n\nfloat traceLight2(vec3 from, vec3 to) {\n    float len = distance(from,to);\n    vec3 dir = (to-from)/len;\n    \n    const float MIN_DISTANCE = 0.1;                             // Distance to scene that we will count as a hit\n    const int MAX_STEPS = 40;                               // Maxmimum amount of ray marching steps before counting the ray as a miss\n    \n    float distanceFromCamera = 0.0;                             // The ray starts at the camera, so 0\n    \n    vec3 raymarchPosition = from;                                   // Variable holding the current position along the camera ray\n    float distanceToScene = GetDistanceToScene(raymarchPosition);\n    \n    for(int i=0;i<MAX_STEPS;i++){\n            if (distanceToScene< MIN_DISTANCE || distanceFromCamera>len) break; // Exit if we hit something, or if the ray goes past MAX_DEPTH\n        \n        distanceFromCamera += distanceToScene;                      // If we didn't exit, move away from the camera...\n            raymarchPosition = from+dir*distanceFromCamera;         // Calculate new position along the camera ray\n        distanceToScene = GetDistanceToScene(raymarchPosition);             // Check how far the new position is away from the scene\n    }\n    return step(len, distanceFromCamera);\n}\n\nvoid main(void){\n    \n  // General parameter setup\n    vec2 vPos = 2.0*gl_FragCoord.xy/iResolution.xy - 1.0;                    // map vPos to -1..1\n    float t = iTime*0.5;                                 // time value, used to animate stuff\n    float screenAspectRatio = iResolution.x/iResolution.y;                    // the aspect ratio of the screen (e.g. 16:9)\n    vec3 finalColor = vec3(0.1);                                // The background color, dark gray in this case\n    \n   //Camera setup\n    Camera cam;                                     // Make a struct holding all camera parameters\n    cam.lookAt = vec3(0,1,0);                               // The point the camera is looking at\n    cam.position = vec3(8.1-4.1, .15, 8.1-4.1);                     // The position of the camera\n    cam.up = vec3(0,1,0);                                   // The up vector, change to make the camera roll, in world space\n    cam.forward = normalize(cam.lookAt-cam.position);                   // The camera forward vector, pointing directly at the lookat point\n    cam.left = cross(cam.forward, cam.up);                          // The left vector, which is perpendicular to both forward and up\n    cam.up = cross(cam.left, cam.forward);                          // The recalculated up vector, in camera space\n \n    vec3 screenOrigin = (cam.position+cam.forward);                     // Position in 3d space of the center of the screen\n    vec3 screenHit = screenOrigin + vPos.x*cam.left*screenAspectRatio + vPos.y*cam.up;  // Position in 3d space where the camera ray intersects the screen\n  \n    cam.rayDir = normalize(screenHit-cam.position);                     // The direction of the current camera ray\n    \n  //Light source\n    vec3 lightSource =  vec3(sin(t)*4.,2.9,cos(t)*4.);\n\n  //Raymarching\n    const float MIN_DISTANCE = 0.1;                             // Distance to scene that we will count as a hit\n    const float MAX_DEPTH=5.0;                              // Distance from camera that we will count as a miss\n    const int MAX_STEPS = 50;                               // Maxmimum amount of ray marching steps before counting the ray as a miss\n    const int FOG_STEPS = 8;\n    \n    float distanceToScene = 1.0;                                // Initial distance to scene, should be initialized as 1\n    float distanceFromCamera = 0.0;                             // The ray starts at the camera, so 0\n    \n    vec3 raymarchPosition;                                  // Variable holding the current position along the camera ray\n            raymarchPosition = cam.position+cam.rayDir*distanceFromCamera;          // Calculate new position along the camera ray\n        distanceToScene = GetDistanceToScene(raymarchPosition);             // Check how far the new position is away from the scene\n    \n    for(int i=0;i<MAX_STEPS;i++){\n            if (distanceToScene< MIN_DISTANCE || distanceFromCamera>MAX_DEPTH) break;   // Exit if we hit something, or if the ray goes past MAX_DEPTH\n        \n        distanceFromCamera += distanceToScene;                      // If we didn't exit, move away from the camera...\n            raymarchPosition = cam.position+cam.rayDir*distanceFromCamera;          // Calculate new position along the camera ray\n        distanceToScene = GetDistanceToScene(raymarchPosition);             // Check how far the new position is away from the scene\n    }\n    \n  //Lighting\n    \n    // Raymarch from light source to raymarch pos (in that direction since it should be slightly faster that way)\n    float lightFalloff = dot(lightSource-raymarchPosition,lightSource-raymarchPosition);\n    float diffuse = traceLight(lightSource, raymarchPosition,.01)/lightFalloff*1.;\n\n    \n    // Take fog samples. These samples are distributed in such a way that each sample catches the same amount of light.\n    \n    // m = distance to the point closest to the light sorce\n    float m = dot(cam.rayDir, lightSource-cam.position);\n    \n    // d = distance to light source at that point\n    float d = length(cam.position-lightSource+m*cam.rayDir);\n    \n    // a,b = start and end points relative to m\n    float a = -m;\n    float b = distanceFromCamera-m;\n    float aa = atan(a/d);\n    float ba = atan(b/d);\n    \n    // t = total light gathered by fog without shadows\n    float to = (ba-aa)/d;\n    \n    \n    float random = fract(sin(iTime+dot(gl_FragCoord.xy, vec2(.1,.163))) * 47267.4);\n    vec3 fog = vec3(0.);\n    for(int i = 0;i<FOG_STEPS; i++) {\n        // s = test point in interval 0..1\n        float s = (random+float(i))/float(FOG_STEPS);\n        \n        // p = actual sampling point in camera ray\n        float p = m+d*tan(s*ba+(1.-s)*aa);\n        \n        vec3 fogTest = cam.position+cam.rayDir*p;\n        fog += traceLight2(lightSource, fogTest)*vec3(i*i,2*i*(FOG_STEPS-1-i),(FOG_STEPS-1-i)*(FOG_STEPS-1-i))/float((FOG_STEPS-1)*(FOG_STEPS-1));\n    }\n    fog *= to*4./float(FOG_STEPS);\n    \n    gl_FragColor = vec4(sqrt(fog), 1.0);                            // Output final color\n}"}