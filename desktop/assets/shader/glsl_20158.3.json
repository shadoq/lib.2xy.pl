{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_20158.3,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"//  By: Brandon Fogerty\n// bfogerty at gmail dot com\n// www.brandonfogerty.com\n// Special Thanks goes to SqueakyNeb and iq\n\nconst float EPS = 0.01;\nconst int MAXI = 100;\n\nmat4 transpose( mat4 m )\n{\n    mat4 t = mat4( vec4( m[0][0], m[1][0], m[2][0], m[3][0] ),\n                   vec4( m[0][1], m[1][1], m[2][1], m[3][1] ),\n                   vec4( m[0][2], m[1][2], m[2][2], m[3][2] ),\n                   vec4( m[0][3], m[1][3], m[2][3], m[3][3] ) );\n    return t;\n}\n\nmat4 invert( mat4 mat )\n{\n    vec3 right =    vec3( mat[0][0], mat[0][1], mat[0][2] );  \n    vec3 up =       vec3( mat[1][0], mat[1][1], mat[1][2] );\n    vec3 fwd =      vec3( mat[2][0], mat[2][1], mat[2][2] );\n    vec3 pos =      vec3( mat[3][0], mat[3][1], mat[3][2] );\n    \n    mat4 t = transpose( mat );\n    \n    t[0][3] = -dot(right, pos);\n    t[1][3] = -dot(right, pos);\n    t[2][3] = -dot(right, pos);\n    \n    return t;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat cube( vec3 ray, float r, mat4 transform )\n{\n    vec3 rayPrime = vec3(transpose( transform ) * vec4(ray,1));\n    float d = length(max(abs(rayPrime)-vec3(0.5,0.5,0.5),0.0))-r;\n    \n    return d;\n}\n\nfloat sphere( vec3 ray, float r, mat4 transform )\n{\n    vec3 rayPrime = vec3(invert( transform ) * vec4(ray,1));\n    float d = length(rayPrime)-r;\n    \n    return d;\n}\n\nfloat SceneDist( vec3 ray )\n{   \n    float t = iTime;\n    float c = cos( t );\n    float s = sin( t );\n    \n    mat4 rotX = mat4(      vec4(1,0,0,0),\n                           vec4(0,c,-s,0),\n                           vec4(0,s,c,0),\n                           vec4(0,0,0,1) );\n    \n    mat4 rotY = mat4(      vec4(c,0,-s,0),\n                           vec4(0,1,0,0),\n                           vec4(s,0,c,0),\n                           vec4(0,0,0,1) );\n    \n    mat4 rotZ = mat4(      vec4(c,s,0,0),\n                           vec4(-s,c,0,0),\n                           vec4(0,0,1,0),\n                           vec4(0,0,0,1) );\n    \n    mat4 pos = mat4(       vec4(1,0,0,s*1.0),\n                           vec4(0,1,0,0),\n                           vec4(0,0,1,c*1.0),\n                           vec4(0,0,0,1) );\n    \n    mat4 transform = pos * rotZ * rotY * rotY;\n\n    float d1 = cube( ray, 0.15, transform );\n    \n    return d1;\n}\n\nvec3 getNormal(vec3 pos){ // this gets the normal\n                          // if you understand, good. if not, not much I can do.\n    vec2 eps = vec2(0.0, EPS);\n    return normalize(vec3( // always normalise directions\n            SceneDist(pos + eps.yxx) - SceneDist(pos - eps.yxx),\n            SceneDist(pos + eps.xyx) - SceneDist(pos - eps.xyx),\n            SceneDist(pos + eps.xxy) - SceneDist(pos - eps.xxy)));\n}\n\nvec3 hsv(float h,float s,float v) { // this is just a hue/saturation/luminance to RGB conversion\n    return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 Lighting( vec3 camPos, vec3 pos, vec3 normal, vec3 diffuseColor )\n{\n    vec3 lightPos = vec3(0,0,10);\n    vec3 lightDir = normalize( lightPos - pos );\n    vec3 viewDir = normalize( camPos - pos );\n    vec3 lightAmbientColor = vec3(0.1,0.1,0.1);\n    vec3 lightSpecularColor = vec3(1,1,1);\n    \n    vec3 halfDir = normalize(viewDir + lightDir);\n    //float lightSpecularIntensity = pow( clamp(dot( normal, halfDir ), 0.0, 1.0), 2.0 );\n    float lightSpecularIntensity = pow( clamp(dot( normal, reflect(lightDir, normal )), 0.0, 1.0), 80.0 );\n    \n    float lightDiffuseIntensity = clamp( dot( -normalize(pos), lightDir ), 0.00, 1.0);\n    \n    \n    return lightAmbientColor + (lightDiffuseIntensity * diffuseColor) + (lightSpecularIntensity * lightSpecularColor);\n    \n}\n\nvec3 RenderScene( vec2 uv )\n{\n    vec3 color = vec3(1,0,0);\n    \n    //vec3 camPos = vec3( sin(iGlobalTime) * 3.0, 0.0, cos(iGlobalTime) * 3.0);\n    vec3 camPos = vec3(0,0,-3);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camUp = vec3(0,1.0,0);\n    vec3 camFwd = normalize( camTarget - camPos );\n    vec3 camRight = normalize( cross( camUp, camFwd ) );\n    camUp = normalize( cross( camRight, camFwd ) );\n    \n    float dist = SceneDist( camPos );\n    float total = dist;\n    vec3 rayDir = vec3( normalize( camFwd + camRight * uv.x + camUp * uv.y ) );\n    \n    for(int i=0; i < MAXI; ++i)\n    {\n        dist = SceneDist( camPos + rayDir * total );\n        total += dist;\n        \n        if( dist <= EPS )\n        {\n            break;\n        }\n    }\n\n    vec3 dest = camPos + rayDir * total;\n    if( dist <= EPS )\n    {\n        color = Lighting( camPos, dest, getNormal( dest ), vec3(1,0,0) );\n    }\n    else    \n    {\n        color = hsv(.55,smoothstep(-1.5,1.,uv.y),1.);\n    }\n    \n    return color;\n}\n\nvoid main(void)\n{\n    vec2 uv = ((gl_FragCoord.xy / iResolution.xy) - 0.5) * vec2(2.0, 2.0 * iResolution.y / iResolution.x);\n    vec3 color = RenderScene( uv );\n    \n    // Scan line\n    color -= mod(gl_FragCoord.y, 2.0) < 1.0 ? 0.5 : 0.0;\n    \n    gl_FragColor = vec4(color, 1.0);\n}"}