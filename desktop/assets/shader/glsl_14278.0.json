{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_14278.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"vec3 hash(in vec3 p) {\n    return fract(sin( mat3(\n        15.34, 75.23, 153.49,\n        359.24, 216.48, 32.64,\n        620.34, 1405.75, 3450.29  \n        ) * p ) * 43768.34);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat voronoi(in vec3 q) {\n    vec3 p = floor(q);\n    vec3 f = fract(q);\n    float d = 0.0;\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++)\n    for(int k = -1; k <= 1; k++) {\n        vec3 b = vec3(i, j, k);\n        float r = length(b + hash(p + b) - f);\n        d += exp( -32.0*r );\n    }\n    return -(1.0/64.0)*log( d );\n}\n\n\n\nfloat Scale = 3.0;                    // 0.0 - 4.0\n\n\n// Scaling center\nvec3 Offset = vec3(1.0,1.0,1.0);        // 0.0 - 1.0\n\n\n// Number of fractal iterations.\nconst int Iterations = 8; // 0 - 100\n\n\n\nfloat NewMenger(vec3 z)\n{\n        //z*=1.9;\n    \n    for(int n = 0; n < Iterations; n++) \n    {\n        //\"z = rot *z;\"\n        //z.z*=0.2*time;\n    //  \"z.x+=0.01*time;\"\n        z = abs(z);\n        if (z.x<z.y){ z.xy = z.yx;}\n        if (z.x< z.z){ z.xz = z.zx;}\n        if (z.y<z.z){ z.yz = z.zy;}\n        z = Scale*z-Offset*(Scale-1.0);\n        if( z.z<-0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\n        }               \n\n    \n    return abs(length(z)-0.0 ) * pow(Scale, float(-Iterations-1));\n}\n\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r ;\n}\n\nfloat map(in vec3 p) {\n    float d = sdPlane(p);\n    d = min(d, sdSphere(p - vec3(0.0, 0.25, 0.0), 0.25));\n    d = min(d,NewMenger(p));\n    return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    );\n    return normalize(nor);\n}\n\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt) {\n    float precis = 0.002;\n    float h = precis * 2.0;\n    float t = 0.0;\n    for(int i = 0; i < 60; i++) {\n        if(abs(h) < precis || t > maxt) continue;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    return t;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 30; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t);\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(1.0);\n    float t = castRay(ro, rd, 20.0);\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n    vec3 lig = normalize(vec3(-0.4, 0.7, 0.5));\n    float dif = clamp(dot(lig, nor), 0.0, 1.0);\n    float spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n    float sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n    col = col * (dif + spec) * clamp(sh, 0.2, 1.0);\n    return col;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float theta = iMouse.x * 3.141592 * 2.0+0.1*iTime;\n    float x = 3.0 * cos(theta);\n    float z = 3.0 * sin(theta);\n    vec3 ro = vec3(x*0.2, 8.0, z*2.);\n    vec3 ta = vec3(0.0, 0.25, 0.0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\n    vec3 col = render(ro, rd);\n    \n    gl_FragColor = vec4(col, 1.0);\n}"}