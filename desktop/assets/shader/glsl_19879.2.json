{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_19879.2,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"\nvec2 hash(vec2 uv) {\n    mat2 m = mat2(15.32, 35.68, 75.42, 153.93);\n    return fract(sin(m * uv) * 43258.21);\n}\n\nvec3 hash(vec3 p) {\n    mat3 m = mat3(15.32, 35.68, 75.42, 153.93, 18.23, 85.75, 254.63, 384.64, 712.98);\n    return fract(sin(m * p) * 43258.21);\n}\n\nvec2 shash(vec2 uv) {\n    return hash(uv) * 2.0 - 1.0;\n}\n\nvec3 shash(vec3 p) {\n    return hash(p) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 uv) {\n    vec2 g = floor(uv);\n    vec2 f = fract(uv);\n    vec2 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    float lb = dot( shash(g + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n    float rb = dot( shash(g + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n    float lt = dot( shash(g + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n    float rt = dot( shash(g + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n    \n    float b = mix(lb, rb, k.x);\n    float t = mix(lt, rt, k.x);\n    return 0.5 + 0.5 * mix(b, t, k.y);\n}\n\nfloat noise(vec3 p) {\n    vec3 g = floor(p);\n    vec3 f = fract(p);\n    vec3 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    float lbu = dot(shash(g + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n    float rbu = dot(shash(g + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n    float ltu = dot(shash(g + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n    float rtu = dot(shash(g + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n    float lbd = dot(shash(g + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n    float rbd = dot(shash(g + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n    float ltd = dot(shash(g + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n    float rtd = dot(shash(g + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n    \n    float bu = mix(lbu, rbu, k.x);\n    float tu = mix(ltu, rtu, k.x);\n    float bd = mix(lbd, rbd, k.x);\n    float td = mix(ltd, rtd, k.x);\n    float u = mix(bu, tu, k.y);\n    float d = mix(bd, td, k.y);\n    return 0.5 + 0.5 * mix(u, d, k.z);\n}\n\nfloat fbm(vec2 uv) {\n    float v = 0.0;\n    mat2 m = mat2(0.8, -0.6, 0.6, 0.8);\n    v += noise(uv) / 2.0; uv = m * uv * 2.01;\n    v += noise(uv) / 4.0;  uv = m * uv * 2.03;\n    v += noise(uv) / 8.0;  uv = m * uv * 2.02;\n    v += noise(uv) / 16.0;\n    return v * 1.3385;\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y + noise(p*100.0)*.001 + .5;\n}\n\nfloat plane(vec3 p) {\n    return p.y + .5;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r + noise(p * 100.0) * 0.01;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cube(vec3 p, vec3 pos, vec3 size) {\n    size /= 2.0;\n    return max(max(abs(p.x+pos.x) - size.x, abs(p.y+pos.y) - size.y), abs(p.z+pos.z) - size.z);\n}\n\nfloat scene(vec3 p) {\n    float d = plane(p);\n    d = min(d, cube(p, vec3(1, - 1.0 - abs(sin(iTime)), 3), vec3(1, 3, 1)));\n    d = min(d, cube(p, vec3(2, 0, 3), vec3(1, 5, 1)));\n    d = min(d, cube(p, vec3(3, 0, 1), vec3(1, 5, 5)));\n    d = min(d, cube(p, vec3(-1, 0, -1), vec3(1, 1, 5)));\n    d = min(d, cube(p, vec3(-3, 0, 3), vec3(7, 5, 1)));\n    d = min(d, cube(p, vec3(-3, 0, 1), vec3(3, 1, 1)));\n    \n    return d + noise(p*100.0)*.001;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    vec3 nor = vec3(scene(p + e.xyy) - scene(p - e.xyy),\n            scene(p + e.yxy) - scene(p - e.yxy),\n            scene(p + e.yyx) - scene(p - e.yyx));\n    return normalize(nor);\n}\n/*\nfloat calcAO(vec3 pos, vec3 nor )\n{\n    float totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n*/\n\nfloat calcAO(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float h = 0.0;\n    float sh = 1.0;\n    for(int i = 0; i < 10; i++) {\n        t += 0.01 + 0.05 * float(i);\n            h = scene(ro + rd * t);\n        sh = min(sh, h * 6.0 / t);\n    }\n    return clamp(sh, -1.0, 1.0) * 0.05 + 0.95;\n}\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    float h = 0.0;\n    float sh = 1.0;\n    for(int i = 0; i < 30; i++) {\n        if(t > maxt) continue;\n        h = scene(ro + rd * t);\n        sh = min(sh, h * 6.0 / t);\n        //sh = h < 0.1 ? 0.0 : 1.0;\n        t += h;\n    }\n    return sh;\n}\n\nfloat castRay(vec3 ro, vec3 rd, float maxt) {\n    float precis = 0.00001;\n    float t = precis * 2.0;\n    for(int i = 0; i < 60; i++) {\n        if(t < precis || t > maxt) continue;\n        float h = scene(ro + rd * t);\n        t += h;\n    }\n    return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(1.0);\n    float t = castRay(ro, rd, 20.0);\n    vec3 p = ro + rd * t;\n    color = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(p.x * 10.0 -1.0) );\n    vec3 lig = normalize(vec3(-0.2, 0.5, 0.3));\n    vec3 nor = calcNormal(p);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n    float sh = shadow(p, lig, 0.02, 20.0);\n    float ao = calcAO(p, nor);\n    color = color * (dif * ao + spec) * (0.2 + 0.8 * sh);\n    color *= exp(-0.01 * t * t);\n    return color;\n}\n\nvoid main( void ) {\n\n    vec2 uv = ( gl_FragCoord.xy / iResolution.xy );\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 1.0, 3.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 cw = normalize(ta - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, up);\n    vec3 cv = cross(cu, cw);\n    vec3 rd = normalize(uv.x * cu + uv.y * cv + 2.0 * cw);\n    \n    float angle = iMouse.x*2.0-1.0;\n    float newX = rd.x*cos(angle) + rd.z*sin(angle);\n    float newZ = rd.z*cos(angle) - rd.x*sin(angle);\n    rd.x = newX;\n    rd.z = newZ;\n    \n    vec3 color = render(ro, rd);\n\n    gl_FragColor = vec4( color, 1.0 );\n\n}"}