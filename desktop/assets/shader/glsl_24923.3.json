{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_24923.3,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"//---------------------------------------------------------\n// Shader:   IllustratedEquations.glsl               4/2015\n//           http://glslsandbox.com/e#24891\n// Original: https://www.shadertoy.com/view/MtBGDW\n//           Created by sofiane benchaa - sben/2015 \n// tags:     procedural, 2d, fractal, trigonometric, curve, complex, iterative\n// info:     http://www.mathcurve.com/surfaces/tore/tn.shtml\n//           http://xrt.wikidot.com/gallery:implicit\n//---------------------------------------------------------\n\n//---------------------------------------------------------\n#define FIELD 28.0\n#define ITERATION 12\n#define CHANNEL bvec3(true,true,true)\n#define PI4 0.7853981633974483\n#define TONE vec3(0.299,0.587,0.114)\n\n//just a line\nfloat crossEQ(vec3 p,float t)\n{\n    float pv = p.x * p.y;\n    return pv * pv;\n}\n\n// triangle\nfloat triangleEQ( vec3 p, float t )\n{\n    return max(abs(p.x)*PI4+p.y*0.5,-p.y) - 0.1+ 0.2*sin(t);\n}\n\n//---------------------------------------------------------\n// regular trifolium\n// http://www.mathcurve.com/surfaces/tore/tn.shtml\n// ((x^2+y^2)^2-x*(x^2-3*y^2))^2+z^2-0.008=0\nfloat bretzTrifolEQ (vec3 p, float t)\n{   \n    float x2 = p.x*p.x;\n    float y2 = p.y*p.y;\n    float fv = (x2+y2)*(x2+y2)-p.x*(x2-3.0*y2);\n    fv *= fv;\n    fv += p.z * p.z;\n    fv /= 0.008+0.006*sin(t);\n    return fv;\n}\n\n// Bretzel6\n// ((x^2+y^2/4-1)*(x*x/4+y*y-1))^2-z^2=0.1\nfloat bretzel6EQ(vec3 p,float t)\n{   \n    float x2 = p.x*p.x;\n    float y2 = p.y*p.y;\n    float fv = (x2+y2/4.-1.)*(x2/4.+y2-1.);\n    fv *= fv;\n    fv += p.z*p.z;\n    fv /= 0.06+0.04*sin(t);\n    return fv;\n}\n\n// quad torus\n// (x^2*(1-x^2)^2*(4-x^2)^3-20*y^2)^2+80*z^2=22\nfloat quadTorusEQ(vec3 p,float t)\n{\n    float x2 = p.x*p.x;\n    float y2 = p.y*p.y;\n    float fv = x2*pow(1.0-x2,2.)*pow(4.0-x2,3.0)-20.0*y2;\n    fv *= fv;\n    fv += 1.0*(p.z*p.z);\n    fv /= 22.0 + 16.*sin(t);\n    return fv;\n}\n//lemniscat Bernoulli\n// ((x^2+y^2)^2-x^2+y^2)^2+z^2=0.01\nfloat bretzBernEQ(vec3 p,float t)\n{\n    float x2 = p.x*p.x;\n    float y2 = p.y*p.y;\n    float fv = ((x2+y2)*(x2+y2)-x2+y2);\n    fv *= fv;\n    fv /= 0.02 + 0.01*sin(t);\n    return fv;\n}\n\n// animated calamari\nfloat pieuvreEQ(vec3 p,float t)\n{\n    float fv = p.x;\n    fv = (p.y+length(p*fv)-cos(t+p.y));\n    fv = (p.y+length(p*fv)-cos(t+p.y));\n    fv = (p.y+length(p*fv)-0.5*cos(t+p.y));\n    fv *= fv*0.1;\n    return fv;\n}\n\n//---------------------------------------------------------\n//iterative equations\n\n//mandelbrot\nfloat mandelbrotEQ(vec3 c,float t)\n{\n    vec4 z = vec4(c,0.0);\n    vec3 zi = vec3(0.0);\n    for(int i=0; i<ITERATION; ++i)\n    {\n        zi.x = (z.x*z.x-z.y*z.y);\n        zi.y = 2.*(z.x*z.y);\n        zi.xyz += c;\n        if(dot(z.xy,z.xy)>4.0)break;\n        z.w++;\n        z.xyz=zi;\n    }\n    z.w /= float(ITERATION);\n    return 1.0-z.w;\n}\n\n//---------------------------------------------------------\n// wolf face\nfloat wolfFaceEQ(vec3 p,float t)\n{\n    vec2 fx = p.xy;\n    p=(abs(p*2.0+sin(t)*0.7));\n    const float j=float(ITERATION);\n    vec2 ab = vec2(2.0-p.x);\n    for(float i=0.0; i<j; i++)\n    {\n        ab+=(p.xy)-cos(length(p));\n        p.y+=sin(ab.x-p.z)*0.5;\n        p.x+=sin(ab.y)*0.5;\n        p-=(p.x+p.y);\n        p+=(fx.y+cos(fx.x));\n        ab += vec2(p.y);\n    }\n    p /= FIELD;\n    return p.x + p.x + p.y;\n}\n\n// dog face\nfloat dogFaceEQ(vec3 p,float t)\n{\n    vec2 fx = p.xy;\n    p=(abs(p*2.0)+sin(t)*0.2);\n    const float j=float(ITERATION);\n    vec2 ab = vec2(2.0-p.x);\n    for(float i=0.0; i<j; i++)\n    {       \n        ab+=p.xy+cos(length(p));\n        p.y+=sin(ab.x-p.z)*0.5;\n        p.x+=sin(ab.y)*0.5;\n        p-=(p.x+p.y);\n        p-=((fx.y)-cos(fx.x));\n    }\n    p /= FIELD;\n    return p.x + p.x + p.y;\n}\n\n//---------------------------------------------------------\nvec3 computeColor(float fv)\n{\n    vec3 color = vec3(vec3(CHANNEL)*TONE);\n    color -= (fv);\n    color.r += color.g*2.0;\n    color.g += color.b;\n    return clamp(color,(0.0),(1.0));\n}\n//---------------------------------------------------------\nvoid main() \n{\n    float ratio = iResolution.y / iResolution.x;\n    vec2 position = ( gl_FragCoord.xy / iResolution.xy )-vec2(0.5, 0.9*ratio);\n    position.y *= ratio;\n    vec3 p = position.xyx*FIELD;\n    \n    p.z = 2.0*FIELD*0.5;\n    vec3 color = computeColor(wolfFaceEQ(p+vec3(7.0, -1.0, 0.2),iTime));\n    p.z = 0.0;  \n    color += computeColor(dogFaceEQ(p*2.0+vec3(0.0,-3.0, 0.0),iTime));\n    color += computeColor(mandelbrotEQ(p+vec3(-5.0,-4.0, 0.0),iTime));\n \n    color += computeColor(triangleEQ(p+vec3(-4.0,-1.0, 0.0),iTime));\n    color += computeColor(crossEQ(p+vec3(+2.3, 6.0, 0.0),iTime));\n\n    color += computeColor(quadTorusEQ(p+vec3(-5.0, 1.0, 0.0),iTime));\n    color += computeColor(bretzTrifolEQ(p+vec3(-6.0, 3.0, 0.0),iTime));\n    color += computeColor(bretzel6EQ(p+vec3(-7.4, -2.0, 0.0),iTime));\n    color += computeColor(bretzBernEQ(p+vec3(-4.0, 3.0, 0.0),iTime));\n        color += computeColor(pieuvreEQ(p*2.5+vec3(-4.0, 4.0, 0.0),iTime));\n    gl_FragColor = vec4( color, 1.0 );\n}\n"}