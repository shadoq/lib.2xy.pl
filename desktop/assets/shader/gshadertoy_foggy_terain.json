{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:gshadertoy_foggy_terain,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// I?igo Quilez's noise functions\nfloat hash(float n)\n{\n  return fract(cos(n) * 41415.92653);\n}\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nmat3 m = mat3( 0.00,  1.60,  1.20, \n              -1.60,  0.72, -0.96, \n              -1.20, -0.96,  2.28 );\nfloat fbm( vec3 p ) // experimented with and kind of modified\n{\n  float f = 0.5000 * noise( p ); p = m * p * 0.72;\n  f += 0.2500 * noise( p ); p = m * p * 0.73;\n  f += 0.1250 * noise( p ); p = m * p * 0.74;\n  f += 0.0625 * noise( p ); p = m * p * 0.75; \n  f += 0.03125 * noise( p ); p = m * p;// * 0.76;\n  //f += 0.015625 * noise( p );// p = m * p;\n  //f += 0.0078125 * noise( p );    \n  return f;\n}\n\n// scene stuff\nfloat objFloor(in vec3 p, in float height) // terrain's just a noisy floor\n{\n    return p.y + height * fbm(vec3(p.xz, 10));\n}\nvec2 scene(in vec3 p)\n{\n    #define FLOOR_HEIGHT 2.5\n    vec2 floorPlane = vec2(objFloor(p, FLOOR_HEIGHT),\n                           1.0);\n    return floorPlane;\n}\n\n// raymarching stuff\nvec3 calcNormal(in vec3 p)\n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    \n    vec3 n;\n    n.x = scene(p + e.xyy).x - scene(p - e.xyy).x;\n    n.y = scene(p + e.yxy).x - scene(p - e.yxy).x;\n    n.z = scene(p + e.yyx).x - scene(p - e.yyx).x;\n    \n    return normalize(n);\n}\n\n#define MAX_STEPS 64\n#define MAX_DEPTH 24.0\nvec2 intersect(in vec3 origin, in vec3 direction)\n{\n    float rayLength = 0.0;\n    vec2 hit = vec2(1.);\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        if (hit.x < 0.001 || rayLength > MAX_DEPTH)\n            break;\n        \n        hit = scene(origin + direction * rayLength);\n         \n        // increment by a slightly reduced length to lessen wavy artifacts\n        rayLength += hit.x * 0.6;\n    }\n        \n    return vec2(rayLength, rayLength > MAX_DEPTH ? \n                           0. : hit.y);\n}\n\nvoid main()\n{\n    // setup space\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = (uv * 2.0 - 1.0); p.x *= iResolution.x / iResolution.y;\n    \n    // setup camera\n    #define SPEED_SCALE 0.125\n    vec3 origin = vec3(3. * cos(SPEED_SCALE * iTime),\n                       1,\n                       2. * sin(SPEED_SCALE * iTime));\n    vec3 target = vec3(0,0,0);\n    \n    // camera direction\n    vec3 direction = normalize(target - origin);\n    // right\n    vec3 right = normalize(cross(direction, vec3(0,1,0)));\n    // up vector\n    vec3 up = normalize(cross(right, direction));\n    // ray direction\n    vec3 rayDirection = normalize(p.x * right + p.y * up + 1.5 * direction);\n    \n    // shade scene\n    vec3 color = mix(vec3(32./255.), //background\n                    vec3(225./255.),\n                    uv.y);\n    // x is the proper distance to the intersection point, y is the material\n    vec2 result = intersect(origin, rayDirection);\n    \n    if (result.y > 0.5)\n    {\n        vec3 position = origin + rayDirection * result.x;\n        vec3 normal = calcNormal(position);\n        vec3 light = normalize(vec3(0., 3., -1.));\n        \n        color = vec3(fbm(vec3(position.xz, 10))) /*\n                 max(0., dot(normal, light))*/;\n    }\n    gl_FragColor = vec4(color, 1.0 );\n}"}