{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_5060.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst int raytraceDepth = 8;\n\n#if 0\nstruct Rect {\n    float left,top,right,bottom;\n    vec4 c;\n};\n\nbool isInRect( Rect r,vec2 v ){\n    if( r.left <= v.x && v.x <= r.right &&\n       r.top <= v.y && v.y <= r.bottom ){\n        return true;\n    }\n    return false;\n}\n#endif\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\nstruct Sphere\n{\n    vec3 c;\n    float r;\n    vec3 col;\n};\n    \nstruct Plane\n{\n    vec3 p;\n    vec3 n;\n    vec3 col;\n};\n    \nstruct Intersection\n{\n    float t;\n    vec3 p;     // hit point\n    vec3 n;     // normal\n    int hit;\n    vec3 col;\n};\n\nvoid shpere_intersect(Sphere s,  Ray ray, inout Intersection isect)\n{\n    // rs = ray.org - sphere.c\n    vec3 rs = ray.org - s.c;\n    float B = dot(rs, ray.dir);\n    float C = dot(rs, rs) - (s.r * s.r);\n    float D = B * B - C;\n\n    if (D > 0.0)\n    {\n        float t = -B - sqrt(D);\n        if ( (t > 0.0) && (t < isect.t) )\n        {\n            isect.t = t;\n            isect.hit = 1;\n\n            // calculate normal.\n            vec3 p = vec3(ray.org.x + ray.dir.x * t,\n                          ray.org.y + ray.dir.y * t,\n                          ray.org.z + ray.dir.z * t);\n            vec3 n = p - s.c;\n            n = normalize(n);\n            isect.n = n;\n            isect.p = p;\n            isect.col = s.col;\n        }\n    }\n}\n\nvoid plane_intersect(Plane pl, Ray ray, inout Intersection isect)\n{\n    // d = -(p . n)\n    // t = -(ray.org . n + d) / (ray.dir . n)\n    float d = -dot(pl.p, pl.n);\n    float v = dot(ray.dir, pl.n);\n\n    if (abs(v) < 1.0e-6)\n        return; // the plane is parallel to the ray.\n\n    float t = -(dot(ray.org, pl.n) + d) / v;\n\n    if ( (t > 0.0) && (t < isect.t) )\n    {\n        isect.hit = 1;\n        isect.t   = t;\n        isect.n   = pl.n;\n\n        vec3 p = vec3(ray.org.x + t * ray.dir.x,\n                      ray.org.y + t * ray.dir.y,\n                      ray.org.z + t * ray.dir.z);\n        isect.p = p;\n        float offset = 0.2;\n        vec3 dp = p + offset;\n        if ((mod(dp.x, 1.0) > 0.5 && mod(dp.z, 1.0) > 0.5)\n        ||  (mod(dp.x, 1.0) < 0.5 && mod(dp.z, 1.0) < 0.5))\n            isect.col = pl.col;\n        else\n            isect.col = pl.col * 0.5;\n    }\n}\n\nSphere sphere[3];\nPlane plane;\n\nvoid Intersect(Ray r, inout Intersection i)\n{\n    for (int c = 0; c < 3; c++){\n//        shpere_intersect(sphere[c], r, i);\n    }\n    shpere_intersect(sphere[0], r, i);\n    shpere_intersect(sphere[1], r, i);\n    shpere_intersect(sphere[2], r, i);\n    \n    plane_intersect(plane, r, i);\n}\n\nint seed = 0;\nfloat random()\n{\n    seed = int(mod(float(seed)*1364.0+626.0, 509.0));\n    return float(seed)/509.0;\n}\nvec3 computeLightShadow(in Intersection isect)\n{\n    int i, j;\n    int ntheta = 16;\n    int nphi   = 16;\n    float eps  = 0.0001;\n\n    // Slightly move ray org towards ray dir to avoid numerical probrem.\n    vec3 p = vec3(isect.p.x + eps * isect.n.x,\n                  isect.p.y + eps * isect.n.y,\n                  isect.p.z + eps * isect.n.z);\n\n    vec3 lightPoint = vec3(5,5,5);\n    Ray ray;\n    ray.org = p;\n    ray.dir = normalize(lightPoint - p);\n\n    Intersection lisect;\n    lisect.hit = 0;\n    lisect.t = 1.0e+30;\n    lisect.n = lisect.p = lisect.col = vec3(0, 0, 0);\n    Intersect(ray, lisect);\n    if (lisect.hit != 0)\n        return vec3(0.0,0.0,0.0);\n    else\n    {\n        float shade = max(0.0, dot(isect.n, ray.dir));\n        shade = pow(shade,3.0) + shade * 0.5;\n        return vec3(shade,shade,shade);\n    }\n    \n}\n    \nvoid main( void ) {\n\n    vec2 position = ( gl_FragCoord.xy / iResolution.xy );\n    position -= vec2( 0.5,0.5 );\n    position.x *= 2.0;\n    \n    vec3 org = vec3(0,0,0);\n    vec3 dir = normalize(vec3(position.x,position.y, -1.0));\n\n        sphere[0].c   = vec3(-2.0, 0.0+sin(iTime)*.5+0.5, -3.5);\n//      sphere[0].c   = vec3( 0.0, 0.0, -2.0);\n        sphere[0].r   = 0.5;\n        sphere[0].col = vec3(1,0.3,0.3);\n        sphere[1].c   = vec3(-0.5, 0.0, -3.0);\n        sphere[1].r   = 0.5;\n        sphere[1].col = vec3(0.3,1,0.3);\n        sphere[2].c   = vec3(1.0, 0.0, -2.2);\n        sphere[2].r   = 0.5;\n        sphere[2].col = vec3(0.3,0.3,1);\n        plane.p = vec3(0,-0.5, 0);\n        plane.n = vec3(0, 1.0, 0);\n        plane.col = vec3(1,1, 1);\n    \n    Ray r;\n    r.org = org;\n    r.dir = normalize(dir);\n    vec4 col = vec4(0,0,0,1);\n    float eps  = 0.0001;\n    vec3 bcol = vec3(1,1,1);\n    for (int j = 0; j < raytraceDepth; j++)\n    {\n        Intersection i;\n        i.hit = 0;\n        i.t = 1.0e+30;\n        i.n = i.p = i.col = vec3(0, 0, 0);\n            \n        Intersect(r, i);\n        if (i.hit != 0)\n        {\n            col.rgb += bcol * i.col * computeLightShadow(i);\n            bcol *= i.col;\n        }\n        else\n        {\n            break;\n        }\n                \n        r.org = vec3(i.p.x + eps * i.n.x,\n                     i.p.y + eps * i.n.y,\n                     i.p.z + eps * i.n.z);\n        r.dir = reflect(r.dir, vec3(i.n.x, i.n.y, i.n.z));\n    }\n    gl_FragColor = col;\n    \n#if 0   \n        Ray r;\n        r.org = org;\n        r.dir = normalize(dir);\n        vec4 col = vec4(0,0,0,1);\n        \n        Intersection i;\n        i.hit = 0;\n        i.t = 1.0e+30;\n//      i.t = 999999.0;\n        i.n = i.p = i.col = vec3(0, 0, 0);\n    \n    \n            \n        Intersect(r, i);\n    \n//  shpere_intersect(sphere[0], r, i);\n//  shpere_intersect(sphere[1], r, i);\n//  shpere_intersect(sphere[2], r, i);\n    \n//  plane_intersect(plane, r, i);\n        \n    if (i.hit != 0){\n        vec3 lightDir = normalize(vec3(1,1,1));\n        \n        float eps  = 0.0001;\n            Ray rsh;\n            rsh.org = i.p + i.n * eps;// ???????????\n            rsh.dir = reflect(r.dir, i.n);// ??????\n            Intersection ish;\n            ish.hit = 0;\n            ish.t = 1.0e+30;\n            ish.n = ish.p = ish.col = vec3(0, 0, 0);\n            Intersect(rsh, ish);\n            \n            col.rgb = max(0.0, dot(i.n, lightDir)) * i.col;\n            col.rgb += ish.col;// ???????????????\n/*\n#if 0\n        // display normal\n        col.rgb = i.n;\n#else\n        // display position\n        col.rgb = i.p;\n        col.b = 0.5;\n#endif  \n*/\n    }\n    gl_FragColor = col;\n#endif  \n    \n    \n//  gl_FragColor = vec4(normalize(dir),1);\n/*  \n    vec4 col = vec4( 0,0,0,1 );\n    \n    vec2 m = mouse / resolution.xy;\n    \n    Rect r;\n    r.left = mouse.x - 0.1;\n    r.top = mouse.y - 0.1;\n    r.right = mouse.x + 0.1;\n    r.bottom = mouse.y + 0.1;\n    r.c = vec4( 1,0,0,1 );\n    \n    if( isInRect( r,position ) ){\n        col = r.c;\n    }\n    gl_FragColor = col;\n*/\n//  gl_FragColor = vec4( position.x,1.0,position.y, 1.0 );\n/*\n    float color = 0.0;\n    color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );\n    color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );\n    color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );\n    color *= sin( time / 10.0 ) * 0.5;\n\n    gl_FragColor = vec4( vec3( color, color * 0.5, sin( color + time / 3.0 ) * 0.75 ), 1.0 );\n*/\n}"}