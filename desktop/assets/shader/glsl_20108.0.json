{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_20108.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"//--------------------------------------------------------------------------------------\n// Flying_Logo, 2013 by Dave Hoskins\n// https://www.shadertoy.com/view/XdX3zN\n//--------------------------------------------------------------------------------------\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n\n//--------------------------------------------------------------------------------------\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\n//--------------------------------------------------------------------------------------\nvec3 rotateY(vec3 v, float x)\n{\n    return vec3(\n        cos(x)*v.x - sin(x)*v.z,\n        v.y,\n        sin(x)*v.x + cos(x)*v.z\n    );\n}\n\nvec3 rotateX(vec3 v, float x)\n{\n    return vec3(\n        v.x,\n        v.y*cos(x) - v.z*sin(x),\n        v.y*sin(x) + v.z*cos(x)\n    );\n}\n\nvec3 rotateZ(vec3 v, float x)\n{\n    return vec3(\n        v.x*cos(x) - v.y*sin(x),\n        v.x*sin(x) + v.y*cos(x),\n        v.z\n    );\n}\n\n//--------------------------------------------------------------------------------------\n// LenghtN. Normal 'length' function uses N = 2.0;\nfloat lengthN(vec3 p, float N)\n{\n    float l = pow(abs(p.x), N) + pow(abs(p.y), N) + pow(abs(p.y), N);\n    return pow(l, 1.0/N);\n}\n\nfloat lengthN(vec2 p, float N)\n{\n    float l = pow(abs(p.x), N) + pow(abs(p.y), N);\n    return pow(l, 1.0/N);\n}\n\n//--------------------------------------------------------------------------------------\nfloat Scene(vec3 p)\n{\n    p = rotateY(rotateZ(p, iTime*.5341), iTime);\n    vec2 q = vec2(lengthN(p.xy, 1.3+sin(iTime*1.234)*.7),p.z);\n    return lengthN(q-6.3, 12.95)+2.4*sin(iTime*1.321)-2.4;\n}\n\n//--------------------------------------------------------------------------------------\nbool RayMarch(vec3 org, vec3 dir, out vec3 p)\n{\n    p=org;\n    bool hit = false;\n    float dist = .0;\n    // 'Break'less ray march...\n    for(int i = 0; i < 120; i++)\n    {\n        if (!hit && dist < 25.0)\n        {\n            p = org + dir*dist;\n            float d = Scene(p);\n            if (d < 0.05)\n            {\n                hit = true;\n            }\n            dist += d*.5;\n        }\n    }\n    return hit;\n}\n\n//--------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n    vec3 eps = vec3(0.01,0.0,0.0);\n    return normalize(vec3(\n        Scene(p+eps.xyy)-Scene(p-eps.xyy),\n        Scene(p+eps.yxy)-Scene(p-eps.yxy),\n        Scene(p+eps.yyx)-Scene(p-eps.yyx)\n        ));\n}\n\n//--------------------------------------------------------------------------------------\nvec3 Background(vec3 rd)\n{\n    return  mix(vec3(0.35, 0.5, .6), vec3(0.6, 0.8, 1.0), rd.y*2.0);\n}\n\n//--------------------------------------------------------------------------------------\nvec3 GetColor(vec3 p, vec3 n, vec3 org, vec3 dir)\n{\n    float lum = clamp(dot(n, lightDir), 0.0, 1.0);\n    vec3 colour = vec3(1.0, .6, 0.0) * lum;\n    //n = dir -2.0*(dot(dir, n))*n;\n    n = reflect(dir, n);\n//  colour += textureCube(channel0, n).xyz;\n    return colour;  \n}\n\n//--------------------------------------------------------------------------------------\nvoid main()\n{\n    vec2 v = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    v.x *= iResolution.x / iResolution.y;\n    \n    vec3 org = vec3(0.0,0.0,-15.0);\n    vec3 dir = normalize(vec3(v.x,v.y,1.0));\n    vec3 colour;\n    vec3 p;\n    \n    bool hit = RayMarch(org,dir,p);\n    if (hit)\n    {\n        vec3 nor = GetNormal(p);\n        nor += (noise(vec2(p.x*4.0, p.y*4.0))-.5) * .15;\n        nor += (noise(vec2(p.x*9.0, p.y*9.0))-.5) * .08;\n        nor = normalize(nor);\n        colour = GetColor(p,nor,org,dir);\n    }else\n    {\n        colour = Background(dir);\n    }\n            \n    gl_FragColor = vec4(colour, 1.0);\n}\n//--------------------------------------------------------------------------------------\n"}