{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:ray_1d_fractal,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"//--------------------------------------------------\n// RayMarch framework v0.2\n// (c) 2014-2015 http://czub.info/\n// Technique are available on blog (in Polish language):\n// http://czub.info/ctx/projekt-raymarching/\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Thanks for IQ for useful article \n// about raymarch technology\n// http://www.iquilezles.org/\n//--------------------------------------------------\n\n#define time iTime\n#define resolution iResolution\n\n//--------------------------------------------------\n// Render Mode:\n// 0 - diffuse color\n// 1 - diffuse color * gray\n// 2 - gray\n// 3 - normal vector\n// 4 - posistion\n// 5 - distance\n// 6 - step\n#define RENDER_MODE 1\n//--------------------------------------------------\n\n//--------------------------------------------------\n// Camera Mode:\n// 0 - Setup in defineCamera function\n#define CAMERA_MODE 0\n//--------------------------------------------------\n\n//--------------------------------------------------\n// Shadow Mode:\n// 0 - disable shadow\n// 1 - hard shadow\n// 2 - soft shadow\n#define SHADOW_MODE 2\n//--------------------------------------------------\n\n// Modes:\n// 0 - Off 1 - On\n#define ENABLE_LIGHT 1\n#define ENABLE_AO 1\n#define ENABLE_MATERIAL 1\n#define ENABLE_TEXTURE 1\n#define ENABLE_SKY 1\n#define ENABLE_SUN 1\n#define ENABLE_REFLECT 1\n#define ENABLE_FOG 1\n\n//--------------------------------------------------\n// RayMarch config\n//--------------------------------------------------\nconst float PI=3.14159;\nconst int MAX_STEPS=128;\nconst float STEPS_DELTA=1.0 / 64.;\nconst float MAX_DISTANCE=100.0;\nconst float DISTANCE_BOOST=1.0;\nconst float EPSILON=0.1;\nconst float NORMAL_EPSILON=0.01;\n\nconst float FOG_POWER=2.0;\n\nconst int SHADOW_ITERATION=8;\nconst float SHADOW_EPSILON=0.001;\nconst float SHADOW_POINT=0.01;\nconst float SHADOW_MIN_DISTANCE=0.02;\nconst float SHADOW_MAX_DISTANCE=2.5;\nconst float SHADOW_BLUR=0.5;\nconst float SHADOW_DELTA=0.0;\nconst float SHADOW_BOOST=1.0;\nconst float SHADOW_OPACITY=0.6;\n\nconst int AO_ITERATION=5;\nconst float AO_START=0.01;\nconst float AO_STEP=0.1;\nconst float AO_BLUR_START=0.70;\nconst float AO_BLUR=0.75;\n\nconst int REFLECT_STEPS=2;\nconst float REFLECT_MULTIPLER=1.0;\nconst float REFLECT_GLOBAL=1.0;\nconst float REFLECT_GLOBAL_ABSORPTION=1.0;\n\nconst int NUM_OF_LIGHTS=1;\nconst int NUM_OF_MATERIALS=9;\n\n//--------------------------------------------------\n// Include section\n// Don't change order\n//--------------------------------------------------\nvec2 map(vec3 p);\n#include \"structures.frag\";\n#include \"camera.frag\";\n#include \"function.frag\";\n#include \"object.frag\";\n#include \"operation.frag\";\n#include \"texture.frag\";\n#include \"light.frag\";\n\n//--------------------------------------------------\n// Camera setup\n//--------------------------------------------------\nvoid  defineCamera(){\n    iCamera=Camera(vec3(6.0, 2.0, 6.0), vec3(0.0), vec3(0.0, 1.0, 0.0), vec3(0.0), vec3(0.0), 1.8);\n}\n\n//--------------------------------------------------\n// Sky setup\n//struct Sky {\n//    vec3 horizontalColor;\n//    vec3 spaceColor;\n//    float horizontal\n//};\n//\n//struct Sun {\n//    vec3 posistion;\n//    vec3 color;\n//    float haloSize;\n//    float haloPower;\n//    float discSize;\n//    float discPower;\n//    float discArea;\n//};\n//--------------------------------------------------\nvoid  defineSky(){\n    sky=Sky(vec3(0.2, 0.1, 0.4), vec3(1.0, 1.0, 1.0), 2.0);\n    sunLight=Sun(vec3(-0.2, 0.1, -0.4), vec3(1.0, 1.0, 1.0), 100.0, 0.3, 100.0, 1.5, 0.9);\n}\n\n//--------------------------------------------------\n// Light setup\n// struct Light {\n//     vec3 posistion;\n//     vec3 ambientColor;\n//     vec3 color;\n// };\n//--------------------------------------------------\nvoid  defineLights(){\n    lights[0]=Light(vec3(cos(iTime)*5.0, 5.0, sin(iTime)*5.0), vec3(0.1, 0.1, 0.1), vec3(1.0, 1.0, 1.0));\n}\n\n//--------------------------------------------------\n// Material setup\n// struct Material {\n//    vec3 ambient;\n//    vec3 diffuse;\n//    vec3 specular;\n//    float shininess;\n//    int texture;\n//    float reflection;\n//    float absorption;\n// };\n//--------------------------------------------------\nvoid  defineMaterials(){\n    materials[0]=Material(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[1]=Material(vec3(0.0, 0.0, 0.0), vec3(0.6, 0.6, 0.6), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[2]=Material(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[3]=Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[4]=Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[5]=Material(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[6]=Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[7]=Material(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n    materials[8]=Material(vec3(0.0, 0.0, 0.0), vec3(0.6, 0.6, 0.6), vec3(1.0, 1.0, 1.0), 16., 0, 0.2, 1.0);\n}\n\n#define MAX_ITTERS  20\n\nfloat deMandelbulb(vec3 vRay)\n{\n    vec3 v=vRay;\n    vec3 c=vec3(0.0);\n\n    float r=0.0;\n    float d=1.0;\n    float fMinDist=10000.0;\n    float u_fPower=0.2;\n    vec3 u_vClamp=vec3(0.0);\n    vec3 u_vOffset=vec3(0.0);\n\n    for(int n=1;n<=MAX_ITTERS;n++)\n    {\n        r=length(v);\n\n        if(r<fMinDist) fMinDist=r;\n        \n        if(r>4.0) break;\n\n        float theta=acos(v.z/r);\n        float phi=atan(v.y,v.x);\n        d=pow(r,u_fPower-1.0)*u_fPower*d+1.0;\n\n        float zr=pow(r,u_fPower);\n        theta=theta*u_fPower;\n        phi=phi*u_fPower;\n\n        v=(vec3(sin(theta)*cos(phi),sin(phi)*sin(theta),cos(theta))*zr)+c;\n\n        if(u_vClamp.x!=0.0) v.x=max(v.x,u_vClamp.x);\n        if(u_vClamp.y!=0.0) v.y=max(v.y,u_vClamp.y);\n        if(u_vClamp.z!=0.0) v.z=max(v.z,u_vClamp.z);\n\n        v+=u_vOffset;\n    }\n    return 0.5*log(r)*r/d;\n}\n\n\n//-------------------------------------\n// Map function\n// Return 2 dimensional vector, where:\n// x - distance\n// y - material ID\n//-------------------------------------\nvec2 map(vec3 p) {\n\n    vec2 hit=vec2(deMandelbulb(p), 0.0);\n    \n//    vec2 hit=plane(p, vec3(0.0, -0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.0);\n//    vec2 cube=roundBox(p, vec3(0.0, 1.0, 0.0), vec3(1.0), 0.2, 1.0);\n//    vec2 sphere=sphere(p, vec3(3.0, 1.0, 0.0), 1.0, 1.0);\n//    vec2 cube3=box(p, vec3(-3.0, 1.0, 0.0), vec3(1.0), 1.0);\n//    \n//    hit=join(hit,cube);\n//    hit=join(hit,sphere);\n//    hit=join(hit,cube3);\n\n    return hit;\n}\n\n//-------------------------------------\n// Shader main function\n//-------------------------------------\nvoid main() {\n\n    vec2 pos=(gl_FragCoord.xy * 2.0 - resolution.xy) / resolution.y;\n    vec2 uv=gl_FragCoord.xy/resolution.xy;\n\n    defineCamera();\n    defineSky();\n    defineMaterials();\n    defineLights();\n\n    //---------------------------------------------------\n    // Camera config\n    //---------------------------------------------------\n    Camera cam=cameraSetup(iCamera);\n    vec3 rayDir=normalize(cam.side * pos.x + cam.up * pos.y + cam.dir * cam.focus);\n    vec3 ray=cam.pos;    \n    \n    vec3 outColor=vec3(0.0, 0.0, 0.0);\n    \n    //\n    // RayMarching\n    //\n    Intersect sceneObject=rayMarching(ray, rayDir);\n    \n    //---------------------------------------------------\n    // Color process\n    //---------------------------------------------------\n    outColor=vec3(0.0, 0.0, 0.0);\n    if (sceneObject.hit){\n        outColor=getColor(outColor, sceneObject, ray, rayDir);\n        #if ENABLE_REFLECT==1\n            outColor=getReflectColor(outColor, sceneObject, ray, rayDir);\n        #endif\n    } else {\n        outColor=getSkyColor(outColor, sceneObject, ray, rayDir);  \n    }\n\n    //---------------------------------------------------\n    // PostProcessing\n    //---------------------------------------------------\n    \n    // Vignette \n    float lenght=length(pos);\n    outColor *= 1.0 - pow(lenght * 0.5, 1.6);\n    \n    gl_FragColor=vec4(outColor.r, outColor.g, outColor.b, 1.0);\n}\n\n"}