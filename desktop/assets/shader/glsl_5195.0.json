{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_5195.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// (c) 2012 Piers Haken\n\n// - added controls for mouse.x\n// - another bounce. works well enough on my 5770.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// uniforms\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// consts\nconst float PI = 3.1415926;\nconst vec3 UP = vec3 (0,0,1);\nconst vec3 Z3 = vec3(0,0,0);\nconst vec3 U3 = vec3(1,1,1);\n\nconst float INFINITY = 1.0/0.0;\n\n// camera\nconst vec3 at = UP;///2.0;\nconst float fov = PI / 2.0;\nfloat tanfov = tan(fov/1.8);\n\n// structs\nstruct Camera\n{\n    vec3 Position;\n    vec3 Side;\n    vec3 Up;\n    vec3 View;\n    vec2 Scale;\n};\n\nstruct Ray\n{\n    vec3 Position;\n    vec3 Direction;\n};\n\nstruct Sphere\n{\n    vec3 Center;\n    float Radius;\n};\n\nstruct Plane\n{\n    vec3 Point;\n    vec3 Normal;\n};\n\nstruct PointLight\n{\n    vec3 Position;\n    vec3 DiffuseColor;\n    float DiffusePower;\n    vec3 SpecularColor;\n    float SpecularPower;\n};\n\nstruct Material\n{\n    vec3 DiffuseColor;\n    vec3 SpecularColor;\n    float Shininess;\n};\n\nstruct Ball\n{\n    Sphere Sphere;\n    Material Material;\n    vec3 Velocity;\n};\n\n\nstruct Bounce\n{\n    Ray Normal;\n    Material Material;\n};\n\n\nconst Material _matFloor = Material (vec3(1,.9,.7), vec3(1,1,1), 130.0);\nconst Plane _floor = Plane (vec3(0,0,0), vec3(0,0,1));\n\nconst int _cLights = 3;\nPointLight _rgLights[_cLights];\n\nconst int _cBalls = 7;\nBall _rgBalls[_cBalls];\n\n\nvec2 Circle (const float time)\n{\n    return vec2 (cos(time), sin(time));\n}\n\n\nfloat IntersectSphere (const Ray ray, const Sphere sphere, inout Ray normal)\n{\n    vec3 L = sphere.Center - ray.Position;\n    float Tca = max (0.0, dot (L, ray.Direction));\n    if (Tca < 0.0)\n        return INFINITY;\n\n    float d2 = dot (L, L) - Tca * Tca;\n    float p2 = sphere.Radius * sphere.Radius - d2;\n    if (p2 < 0.0)\n        return INFINITY;\n\n    float t = Tca - sqrt (p2);\n    vec3 intersect = ray.Position + t * ray.Direction;\n    normal = Ray (intersect, (intersect - sphere.Center) / sphere.Radius);\n    return t;\n}\n\nfloat IntersectPlane (const Ray ray, const Plane plane, inout Ray normal)\n{\n    float t = dot (plane.Point - ray.Position, plane.Normal) / dot (ray.Direction, plane.Normal);\n    normal = Ray (ray.Position + t * ray.Direction, plane.Normal);\n    return t;\n}\n\nvec3 Phong (PointLight light, Material material, Ray normal, vec3 eye)\n{\n    vec3 viewDir = normalize (normal.Position - eye);\n    vec3 lightVec = light.Position - normal.Position;\n    float lightDistance2 = dot (lightVec, lightVec);\n    vec3 lightDir = lightVec / sqrt (lightDistance2);\n    float diffuse = dot(normal.Direction, lightDir);\n\n    vec3 R = lightDir - 2.0 * diffuse * normal.Direction;\n    float specular = pow(max(0.0, dot(R, viewDir)), material.Shininess);\n\n    vec3 color =\n        max (0.0, diffuse) * light.DiffuseColor * light.DiffusePower * material.DiffuseColor +\n        max (0.0, specular) * light.SpecularColor * light.SpecularPower * material.SpecularColor;\n\n    return color * 110.0 / lightDistance2;\n}\n\nbool Scene (const Ray ray, out Bounce bounce)\n{\n    float tMatch = INFINITY;\n    Ray normalMatch;\n    for (int i = 0; i < _cBalls; ++i)\n    {\n        Ray normal;\n        float t = max(0.0, IntersectSphere (ray, _rgBalls[i].Sphere, normal));\n        if (t > 0.0 && tMatch > t)\n        {\n            tMatch = t;\n            bounce = Bounce (normal, _rgBalls[i].Material);\n        }\n    }\n\n    Ray normalPlane;\n    float t2 = IntersectPlane (ray, _floor, normalPlane);\n    if (t2 > 0.0 && t2 < tMatch)\n    {\n        vec3 pt = normalPlane.Position;\n        if (length(pt) < 10.0 && (fract(pt.x) < 0.9 == fract(pt.y) < 0.9))\n        {\n            tMatch = t2;\n            bounce = Bounce (normalPlane, _matFloor);\n        }\n    }\n\n    return tMatch < 1000.0 && tMatch > 0.0;\n}\n\nbool LightScene (inout Ray ray, inout vec3 color)\n{\n    Bounce bounce;\n    if (!Scene (ray, bounce))\n        return false;\n\n    vec3 bouncePos = bounce.Normal.Position + bounce.Normal.Direction * .0001;\n\n    Bounce bounceShadow;\n\n    for (int iLight = 0; iLight < _cLights; ++iLight)\n    {\n        if (!Scene (Ray (bouncePos, normalize (_rgLights[iLight].Position - bouncePos)), bounceShadow))\n            color += Phong (_rgLights[iLight], bounce.Material, bounce.Normal, ray.Position);\n    }\n\n    ray = Ray (bouncePos, reflect (ray.Direction, bounce.Normal.Direction));\n    return true;    \n}\n\nconst Sphere s = Sphere (Z3, .5);\n\nvoid main( void )\n{\n    float time2 = iTime / 10.0 + 100.0;\n\n    vec3 eye = vec3(Circle(iTime / 10.0 + 10.0 * mouse.x) * (7.1 - 4.5 * mouse.y), 4.5 * mouse.y);\n    vec3 look = normalize (at - eye);\n\n    vec3 u = cross (look, UP);\n    vec3 v = cross (u, look);\n\n    vec3 dx = tanfov * u;\n    vec3 dy = tanfov * v;\n\n    vec2 position = (gl_FragCoord.xy - iResolution/2.0) / min(iResolution.x, iResolution.y);\n    Ray ray = Ray (eye, normalize (look + dx * position.x + dy * position.y));\n\n    _rgBalls[0] = Ball(s, Material (vec3(1,0,0), U3, 100.0), vec3(1.17, 1.9, 3.03));\n    _rgBalls[1] = Ball(s, Material (vec3(1,1,0), U3, 100.0), vec3(1.23, 1.8, 1.79));\n    _rgBalls[2] = Ball(s, Material (vec3(0,0,1), U3, 100.0), vec3(1.35, 1.7, 2.73));\n\n    _rgBalls[3] = Ball(s, Material (vec3(0,1,1), U3, 100.0), vec3(1.41, 1.6, 2.53));\n    _rgBalls[4] = Ball(s, Material (vec3(1,0,1), U3, 100.0), vec3(1.50, 1.5, 2.23));\n    _rgBalls[5] = Ball(s, Material (vec3(1,1,0), U3, 100.0), vec3(1.69, 1.4, 1.93));\n\n    _rgBalls[6] = Ball(s, Material (vec3(0,0,0), U3, 100.0), vec3(1.39, 1.19, 1.93));\n    //_rgBalls[7] = Ball(s, Material (vec3(1,1,1), U3, 100.0), vec3(1.73, 1.01, 1.93));\n\n    for (int i = 0; i < _cBalls; ++i)\n    {\n        float q = fract(time2 * _rgBalls[i].Velocity.z / 3.0) - 0.5;\n\n        _rgBalls[i].Sphere.Center = vec3 (\n            abs(mod(time2 * _rgBalls[i].Velocity.xy, 8.0) - 4.0) - 2.0,\n            _rgBalls[i].Sphere.Radius + 8.0 * (0.25-q*q));\n    }\n\n\n    _rgLights [0] = PointLight (4.0*vec3(1,0.,2), vec3(.5,1,.5), .3, vec3(.5,1,.5), 1.0);\n    _rgLights [1] = PointLight (4.0*vec3(-1,-0.86,2), vec3(1,.5,.5), .3, vec3(1,.5,.5), 1.0);\n    _rgLights [2] = PointLight (4.0*vec3(-1,0.86,2), vec3(.5,.5,1), .3, vec3(.5,.5,1), 1.0);\n\n\n    vec3 color = vec3(0,0,0);\n\n    LightScene (ray, color) &&\n        LightScene (ray, color) &&\n        LightScene (ray, color) &&\n        LightScene (ray, color);\n\n    gl_FragColor = vec4 (color, 1.0);\n}\n"}