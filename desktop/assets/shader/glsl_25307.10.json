{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_25307.10,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n// I should really add anti-aliasing or soft-shadows.  The former is probably low hanging fruit. \n// I can't think of an elegant solution to generating unique random numbers on every fragment \n// though to calculate all the offsets.\n\n// broken in windows firefox\n// Essentially, given some geometry and a ray, find the point at which the\n// I should do a blog post about how I switched to Egyptian-brace style after picking up Rust ...\n//\n// do I need to explain what a directional light is?\n// shader optimization, as with OpenCL, defer conditionals/returns as later as possible and\n// when you have to branch, try to load both branches evenly.\n\n// I start with a simple ray definition, consisting of an origin point and a\n// direction vector. I also define a directional light to illuminate my scene.\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 color;\n    vec3 direction;\n};\n\n// In real life, objects have many different material properties. Some objects\n// respond very differently to light than others. For instance, a sheet of paper\n// and a polished mirror. The former exhibits a strong *diffuse* response;\n// incoming light is reflected at many angles. The latter is an example of a\n// *specular* response, where incoming light is reflected in a single direction.\n// To model this, I create a basic material definition. Objects in my scene\n// share a single (RGB) color with diffuse and specular weights.\nstruct Material {\n    vec3 color;\n    float diffuse;\n    float specular;\n};\n\n// To render the scene, I need to know where a ray intersects with an object.\n// Since rays have infinite length from an origin, I can model the point of\n// intersection by storing the distance along the ray. I also need to store the\n// surface normal so I know which way to bounce! Once I create a ray, it loses\n// the concept of scene geometry, so one more thing I do is forward the surface\n// material properties.\nstruct Intersect {\n    float len;\n    vec3 normal;\n    Material material;\n};\n\n// The last data structures I create are for objects used to fill my scene. The\n// most basic object I can model is a sphere, which is defined as a radius at\n// some center position, with some material properties. To draw the floor, I\n// also define a simple horizontal plane centered at the origin, with a normal\n// vector pointing upwards.\nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 normal;\n    Material material;\n};\n\n// Magic numbers ... everybody hates them! First up, I define an epsilon value.\n// This is to help mitigate floating point errors.\n\n// Due to floating point precision errors, when a ray intersects geometry at a\n// surface, the point of intersection could possibly be just below the surface.\n// The subsequent reflection ray would then bounce off the *inside* wall of the\n// surface. This is known as self-intersection.\n// ~~~~~~\nconst float epsilon = 1e-3;\n\n// The classical ray tracing algorithm is recursive. However, GLSL does not\n// support recursion, so I instead use an iterative approach to control the\n// number of light bounces.\nconst int iterations = 15;\n\n// Next, I define an exposure time and gamma value. These are used to control\n// the image brightness. This is different from changing the intensity of\n// ~~~~~\nconst float exposure = 1e-2;\nconst float gamma = 2.2;\n\n// At this point, I create a basic directional light. I also define the ambient\n// light color; the color here is mostly a matter of taste.\nconst float intensity = 50.0;\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\n// For a Static Light\n// Light light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\n\n// For a Rotating Light\n Light light = Light(vec3(1.0) * intensity, normalize(\n                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\n                      1.0 + 4.0 * sin(iTime))));\n\n// I strongly dislike this line. I needed to know when a ray hits or misses a\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\n// the ray misses all geometry and instead hits the skybox. In a language that\n// supports dynamic return values, I could `return false`, but that is not an\n// option in GLSL. In the interests of making progress, I created an intersect\n// of distance (--zero--) -1 to represent a miss and moved on.\nconst Intersect miss = Intersect(-1.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\n// intersection is relatively straightforward. For reflection purposes, a ray\n// either hits or misses, so I need to check for no solutions, or two solutions.\n// In the latter case, I need to determine which solution is \"in front\" so I can\n// return an intersection of appropriate distance from the ray origin.\nIntersect intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.position - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n    if (det <= 0.00001) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n}\n\n// Since I created a floor plane, I also have to handle reflections for planes\n// by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\n// intersection. I only care about the intersect for the purposes of reflection,\n// so I only check if the quotient is non-zero.\nIntersect intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.origin, plane.normal) / ( dot(ray.direction, plane.normal) + 0.0001 );\n    if (len < 0.0) return miss;\n    else return Intersect(len, plane.normal, plane.material); \n}\n\n// In a *real* ray tracing renderer, geometry would be passed in from the host\n// as a mesh containing vertices, normals, and texture coordinates, but for the\n// sake of simplicity, I've hand-coded the scenegraph. In this function, I take\n// an input ray and iterate through all geometry to determine intersections.\nIntersect trace(Ray ray) {\n    const int num_spheres = 3;\n    Sphere spheres[num_spheres];\n\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\n    // scene definition, but soon found performance was abysmal on very large\n    // spheres. I kept the general format, modified to fit my data structures.\n\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.0), 1.0, 0.001));\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 1.0, 0.0), 1.0, 0.001));\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),           Material(vec3(0.0, 0.0, 1.0), 0.5, 0.25));\n\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\n    // with the plane, then loop through all spheres back-to-front.\n\n    Intersect intersection = miss;\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(0.5, 0.2, 0.0), 1.0, 0.0)));\n//    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) \n    if (plane.len >= 0.0) //not miss?\n    {\n        intersection = plane;\n    }\n    for (int i = 0; i < num_spheres; i++) {\n        Intersect sphere = intersect(ray, spheres[i]);\n//        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n        if (sphere.len >= 0.0) //not miss?\n            intersection = sphere;\n    }\n    return intersection;\n}\n\n// This is the critical part of writing a ray tracer. I start with some empty\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\n// using an input ray, and continue to fire new rays until the iteration depth\n// is reached, at which point I return the total sum of the color values from\n// computed at each bounce.\nvec3 radiance(Ray ray) {\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    Intersect hit;\n    for (int i = 0; i <= iterations; ++i) {\n        hit = trace(ray);\n\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\n        // trace returns an intersection with either a diffuse or specular\n        // coefficient, then it has encountered a surface of a primitive.\n        // Otherwise, the current ray has reached the ambient-colored skybox.\n\n//        if (hit.material.diffuse >= 0.01 || hit.material.specular > 0.001) \n        if (hit.len >= 0.0) //not miss?\n    { \n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\n            // to determine the Fresnel specular contribution factor, a measure\n            // of how much incoming light is reflected or refracted. I compute\n            // this value first and then subtract it out later when I do the\n            // diffuse coloring to create a smooth gradient background effect.\n\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0); \n        mask *= fresnel;\n\n            // Here is where I handle shadows and diffuse colors. I condensed\n            // this part into one conditional evaluation for brevity. Remember\n            // `epsilon` the magic ~~dragon~~ number? I use this to fire a new\n            // ray slightly offset from the original point of intersection in\n            // the *direction of the light source* to determine if the intersect\n            // should be in a shadow. FIXME\n\n            // ~~~~~~~~~~~~~~~~\n\n        // the condition statement can not be compiled on my pc/win7/GeForceGT610 -> compiled with errors\n//      if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) \n\n            Intersect isec = trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction));\n//      if (isec == miss)  // !!! this condition statement is the malefactor !!!\n        if (isec.len < 0.01) // is miss?\n        {\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\n                       * hit.material.color.rgb * hit.material.diffuse  // Add Diffuse\n                       * (1.0 - fresnel) * mask / fresnel;         // Subtract Specular\n            }\n\n\n            // After computing diffuse colors, I then generate a new reflection\n            // ray and overwrite the original ray that was passed in as an\n            // argument to the radiance(...) function. Then I repeat until I\n            // reach the iteration depth.\n\n            vec3 reflection = reflect(ray.direction, hit.normal);\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\n\n        } else {\n\n            // This is the other half of the tracing branch. If the trace failed\n            // to return an intersection with an attached material, then it is\n            // safe to assume that the ray points at the sky, or out of bounds\n            // of the scene. At this point I realized that real objects have a\n            // small sheen to them, so I hard-coded a small spotlight pointing\n            // in the same direction as the main light for pseudo-realism.\n\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\n            color += mask * (ambient + spotlight); break;\n        }\n    }\n    return color;\n}\n\n// The main function primarily deals with organizing data from OpenGL into a\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\n// fragment coordinates do not map exactly, so I need to divide the fragment\n// coordinates by the viewport resolution. I then offset that by a fixed value\n// to re-center the coordinate system.\n\n// void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n//     vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n//          uv.x *= iResolution.x / iResolution.y;\n\n//     // For each fragment, create a ray at a fixed point of origin directed at\n//     // the coordinates of each fragment. The last thing before writing the color\n//     // to the fragment is to post-process the pixel values using tone-mapping.\n//     // In this case, I adjust for exposure and perform linear gamma correction.\n\n//     Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n//     fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n// }\n\n\nvoid main() {\n//    vec2 uv = 2. * gl_FragCoord.xy / resolution.xy - 1.;\n  // vec2 uvs = uv * resolution.xy / max(resolution.x, resolution.y);\n    vec2 uv    = gl_FragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\n    // For each fragment, create a ray at a fixed point of origin directed at\n    // the coordinates of each fragment. The last thing before writing the color\n    // to the fragment is to post-process the pixel values using tone-mapping.\n    // In this case, I adjust for exposure and perform linear gamma correction.\n\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    gl_FragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n}\n"}