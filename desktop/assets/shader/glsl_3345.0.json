{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_3345.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// a inefficient small ray tracing for educational purposes\n// by @xbelanch \n// after seeing similar stuff or GLSL demos like:\n// smallpt: a small ray tracing based on Kevin Beason's smallpt project (http://www.kevinbeason.com/smallpt/)\n// http://glsl.heroku.com/e#3334.0\n// http://glsl.heroku.com/e#3165.0\n// http://glsl.heroku.com/e#3161.2\n// http://glsl.heroku.com/e#1686.0\n// http://glsl.heroku.com/e#1556.1\n \n#define MAXSPHERES 10\n\n// types of surface\n#define DIFFUSE 1\n#define SPECULAR 2\n#define MIRROR 3\n#define REFRACTIVE 4\n#define LIGHT 5\n\n    vec3 org = vec3(0,0.5,0);\n    vec2 pixel = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 dir = normalize(vec3(asp*pixel.x, pixel.y, -1.0));\n\n// Structures\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    int tReflection; \n};\n\nstruct Intersection\n{\n    float t;\n    vec3 hitPoint; // hit point\n    vec3 normal; // normal\n    vec3 color;\n    int hit;\n    int tReflection;\n};\n\n// ray-objects functions\n\nvoid intersectionSphere(Sphere sphere, Ray ray, inout Intersection isect)\n{\n    float t;\n    float epsilon = 1e-4;\n    vec3 op = ray.origin - sphere.center;\n    float b = dot(op, ray.direction);\n    float c = dot(op, op) - (sphere.radius * sphere.radius);\n    // solve determinant\n    float determinant = b * b - c;\n    if (determinant > 0.0)\n    {\n        determinant = sqrt(determinant);\n        t = -b - determinant;\n        if ( t > epsilon  && t < isect.t)\n        {\n            isect.t = t;\n            isect.hit = 1;\n            isect.color = sphere.color;\n            // calculate normal\n            vec3 p = vec3(ray.origin.x + ray.direction.x * t,\n                          ray.origin.y + ray.direction.y * t,\n                          ray.origin.z + ray.direction.z * t);      \n            vec3 n = p - sphere.center;\n            n = normalize(n);\n            isect.normal = n;\n            isect.hitPoint = p;\n            isect.tReflection = sphere.tReflection;\n        }\n    }\n}\n\n\n// calculate reflection\nvec3 reflection(vec3 dir, vec3 normal)\n{\n    dir = normalize(dir);\n    return dir - normal * 2.0 * dot(normal, dir);\n}\n\n\n\nSphere sphere[MAXSPHERES];\n\nvoid Intersect(Ray ray, inout Intersection isect)\n{\n    for(int c = 0; c < MAXSPHERES; c++)\n    {\n        intersectionSphere(sphere[c], ray, isect);\n    }\n}\n\n// is anything between the points \"src\" (point on surface) and \"dst\" (light source)?\n// need to calculate shadows \nbool rayBlocked(vec3 src, vec3 dst)\n{\n    vec3 dir = dst - src;\n    float length = sqrt(dot(dir, dir));\n    dir = dir / length;\n\n    Intersection i;\n    i.t = length - 0.01; // because we use a spehere as a light point!\n    i.hit = 0;\n    // create a new ray\n    Ray ray;\n    ray.origin = src;\n    ray.direction = normalize(dir);\n    Intersect(ray, i);\n    return i.hit != 0 ? true : false;\n}\n\n// calculate color\nvec3 calculateLight(vec3 src, vec3 dst, Intersection i)\n{\n    vec3 color = vec3(.15, .15, .15); // ambient color\n\n    if (!rayBlocked(src, dst))\n    {\n        // diffuse calculation goes here\n        vec3 dir = (dst - src); // change to sub! :-S  pay attention of this!\n        float invDist= 1.0 / sqrt(dot(dir, dir));\n        dir = dir*invDist; // normalize\n        float diffuse = dot(dir, i.normal);\n        if (diffuse > 0.0)\n        {\n            color += color * diffuse * i.color * invDist *  8.35;\n        }\n        \n        // specular and reflection calculation goes here\n        if (i.tReflection == SPECULAR)\n        {\n            dir = normalize(dir);\n            float attenuation = 1.5;\n            // vec3 lightReflect =  i.normal * dot(i.normal * 2.0, dir) - dir;\n            vec3 lightReflect = i.normal * dot(i.normal * 2.0, dir) - dir;\n            float cosFactor = dot(i.normal, lightReflect);\n            if (cosFactor > 0.0)\n            {\n                float thisSpecular =  pow(cosFactor, 200.0);\n                thisSpecular *= attenuation;\n                color += thisSpecular;\n            }\n        }\n    }\n\n    // if (!rayBlocked(src,dst) && i.tReflection == MIRROR)\n    // {\n    //  vec3 dir = (dst - src);\n    // }\n\n    if (rayBlocked(src, dst)) {\n        // simple diffuse shadow\n        color = vec3(.1, .1, .1);\n        vec3 dir = (dst - src); \n        float invDist= 1.0 / sqrt(dot(dir, dir));\n        dir = dir*invDist; \n        float diffuse = dot(dir, i.normal);\n        if (diffuse > 0.0)\n        {\n\n            color += color * diffuse * i.color * invDist *  2.35;\n        }\n    }\n\n\n    return color;\n}\n\n\n// simple tracer\nvec3 traceRay(Ray ray, Intersection isect, vec3 lightPos)\n{\n    vec3 color = vec3 (.0, .0, .0);\n    Intersect(ray, isect);\n    if (isect.hit != 0)\n    {\n\n        color = calculateLight(isect.hitPoint, lightPos, isect);\n        // first ray pass \n        if (isect.tReflection == MIRROR) \n        {\n            // reset t\n            isect.t = 1e20;\n            isect.hit = 0;\n            ray.origin = isect.hitPoint;  // from the hit point\n            // calculate reflecton dir\n            ray.direction = normalize(reflection(ray.direction, isect.normal));\n            Intersect(ray, isect);\n            if (isect.hit !=0)\n            {\n                \n                color = calculateLight(isect.hitPoint, lightPos, isect);\n                // second ray pass \n                // uncomment if you want two reflection rays pass\n                // if (isect.tReflection == MIRROR) \n                // {\n                //  // reset t\n                //  isect.t = 1e20;\n                //  isect.hit = 0;\n                //  ray.origin = isect.hitPoint;  // from the hit point\n                //  // calculate reflecton dir\n                //  ray.direction = normalize(reflection(ray.direction, isect.normal));\n                //  Intersect(ray, isect);\n                //  if (isect.hit !=0)\n                //  {\n                //      color = calculateLight(isect.hitPoint, lightPos, isect);\n                //  }\n                // }\n            }\n        \n        }\n\n    }\n    return color;\n}\n\n\n\nvoid main()\n{\n    // Objects\n    // sphere mirror green\n    /*\n    sphere[0].radius = .85;\n    sphere[0].center = vec3((sin(time*.5)*2.), -.9, -2.9);\n    sphere[0].color = vec3(.0, 1., .0);\n    sphere[0].tReflection = MIRROR;\n    */\n\n    // sphere diffuse green\n    /*\n    sphere[1].radius = .3;\n    sphere[1].center = vec3(-1.0+(sin(time*1.)), 0.3, -0.85-(cos(time*1.)));\n    sphere[1].color = vec3(.0, .75, .0);\n    sphere[1].tReflection = DIFFUSE;\n    */\n\n    // sphere specular orange\n    /*\n    sphere[9].radius = .55;\n    sphere[9].center = vec3((sin(time*1.2)*2.), .9, -2.9);\n    sphere[9].color = vec3(1., .5, .0);\n    sphere[9].tReflection = SPECULAR;\n    */\n\n    // wall right\n    sphere[2].radius = 1e5;\n    sphere[2].center = vec3(1e5+2.5, 40.8, 81.6);\n    sphere[2].color = vec3(.25, .25, .75);\n    sphere[2].tReflection = DIFFUSE;\n\n    // wall left\n    sphere[3].radius = 1e5;\n    sphere[3].center = vec3(-1e5-2.5, 40.8, 81.6);\n    sphere[3].color = vec3(.75, .25, .25);\n    sphere[3].tReflection = DIFFUSE;\n\n    // wall back\n    /*\n    sphere[4].radius = 1e5;\n    sphere[4].center = vec3(50., 40.8, -1e5-3.4);\n    sphere[4].color = vec3(.75, .75, .75);\n    sphere[4].tReflection = DIFFUSE;\n    */\n    // wall top\n    /*\n    sphere[5].radius = 1e5;\n    sphere[5].center = vec3(50., 1e5+2.2, 40.8);\n    sphere[5].color = vec3(.75, .75, .75);\n    sphere[5].tReflection = DIFFUSE;\n    */\n    // wall bottom\n    /*\n    sphere[6].radius = 1e5;\n    sphere[6].center = vec3(50., -1e5-1.5, 40.8);\n    sphere[6].color = vec3(.75, .75, .75);\n    sphere[6].tReflection = DIFFUSE;\n    */\n\n    // wall front\n    /*\n    sphere[7].radius = 1e5;\n    sphere[7].center = vec3(50., 40.8, 1e5+3.4);\n    sphere[7].color = vec3(.0, .0, .0);\n    sphere[7].tReflection = DIFFUSE;\n    */\n    // sphere light\n    sphere[8].radius = .0;\n    // sphere[8].center = vec3((cos(time*.5)), .05+0.325, -1.2 + (cos(time*1.2)));\n    sphere[8].center = vec3(0., 1.3, -0.99);\n\n    sphere[8].color = vec3(0.8, 0.1, 0.8); // hey! nothing changes if you modify the color of the light!\n    sphere[8].tReflection = LIGHT;\n\n\n    Ray ray;\n    ray.origin = org;\n    ray.direction = normalize(dir);\n\n    Intersection isect;\n    isect.t = 1e20;\n    isect.hit = 0;\n\n    vec4 color = vec4(.0, .0, .0, 0);\n    vec4 backgroundColor = vec4(.55, .75, .8, 0);\n    color = backgroundColor;\n\n\n    color.rgb =  traceRay(ray, isect, sphere[8].center);\n    gl_FragColor = color;\n    gl_FragColor.a = 1.0;\n}"}