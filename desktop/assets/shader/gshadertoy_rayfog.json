{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:gshadertoy_rayfog,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// TODO: try different amplitudes and frequencies\n\n\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nstruct SMaterial\n{\n    vec3 m_diffuseColor;\n    float m_specular;\n    vec3 m_specularColor;\n};\n\n//=======================================================================================\nstruct SCollisionInfo\n{\n    int         m_Id;\n    bool        m_foundHit;\n    bool        m_fromInside;\n    float       m_collisionTime;\n    vec3        m_intersectionPoint;\n    vec3        m_surfaceNormal;\n    SMaterial   m_material;\n};\n\n//=======================================================================================\nstruct SSphere\n{\n    int         m_Id;\n    vec3        m_center;\n    float       m_radius;\n    SMaterial   m_material;\n};\n    \n//=======================================================================================\nstruct SAxisAlignedBox\n{\n    int         m_Id;\n    vec3        m_pos;\n    vec3        m_scale;\n    SMaterial   m_material;\n};\n    \n//=======================================================================================\nstruct SPointLight\n{\n    vec3        m_pos;\n    vec3        m_color;\n};\n    \n//=======================================================================================\nstruct SDirLight\n{\n    vec3        m_reverseDir;\n    vec3        m_color;\n};\n    \n//=======================================================================================\nstruct SShadingStackItem\n{\n    vec3        m_addColor;\n    vec4        m_fogColorAndAmount;\n};\n    \n//=======================================================================================\n// Scene parameters\n//=======================================================================================\n    \n//----- settings\n#define DO_SHADOWS true // setting this to false will speed up rendering\n    \n//----- camera\nvec2 mouse = iMouse.xy / iResolution.xy;\n\nvec3 getCameraPos ()\n{\n    return vec3(0,1.0,-4.0);\n}\n\nvec3 getCameraAt ()\n{\n    vec3 pos = getCameraPos();\n    \n    return pos + vec3(0.0,-1.0,4.0);\n}\n\nvec3 cameraPos  = getCameraPos();\nvec3 cameraAt   = getCameraAt();\n\nvec3 cameraFwd  = normalize(cameraAt - cameraPos);\nvec3 cameraLeft  = normalize(vec3(-1.0,0.0,0.0));\nvec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\nfloat cameraViewWidth   = 6.0;\nfloat cameraViewHeight  = cameraViewWidth * iResolution.y / iResolution.x;\nfloat cameraDistance    = 6.0;  // intuitively backwards!\n\n//----- shading stack\nSShadingStackItem shadingStack;\n\n//----- lights\nvec3 lightAmbient               = vec3(0.1,0.1,0.1);\n\nvec3 fogColor = vec3(0.5,0.5,0.5);\n\nSDirLight lightDir1 =\n    SDirLight\n    (\n        normalize(vec3(-1.0,1.0,-1.0)),\n        vec3(1.0,1.0,1.0)\n    );\n\nSPointLight lightPoint1 =\n    SPointLight\n    (\n        vec3(sin(1.57 + iTime*1.3),0.3,cos(1.57 + iTime*1.3)),\n        vec3(0.7,0.3,0.7)\n    );\n\n//----- primitives\nSSphere lightPoint1Sphere =\n    SSphere\n    (\n        1,                      //id\n        lightPoint1.m_pos,      //center\n        0.06,                   //radius\n        SMaterial\n        (\n            lightPoint1.m_color,//diffuse color\n            1.0,                //specular amount\n            vec3(0.0,0.0,0.0)   //specular color\n        )\n    );  \n\nSSphere sphere1 =\n    SSphere\n    (\n        2,                      //id\n        vec3(0.0,0.0,0.0),      //center\n        0.2,                    //radius\n        SMaterial\n        (\n            vec3(0.0,1.0,0.0),  //diffuse color\n            10.0,               //specular amount\n            vec3(1.0,1.0,1.0)   //specular color\n        )\n    );\n\nSSphere sphere2 =\n    SSphere\n    (\n        3,                      //id\n        vec3(sin(iTime*1.3),sin(3.14 + iTime * 1.4)*0.25,cos(iTime*1.3)), //center\n        0.15,                   //radius\n        SMaterial\n        (\n            vec3(0.0,1.0,1.0),  //diffuse color\n            3.0,                //specular amount\n            vec3(1.0,1.0,1.0)   //specular color\n        )\n    );\n\nSAxisAlignedBox orbitBox = \n    SAxisAlignedBox\n    (\n        4,                      //Id\n        vec3(sin(2.0 + iTime*1.3),-0.2,cos(2.0 + iTime*1.3)),   //center\n        vec3(0.5,0.5,0.5),  //scale\n        SMaterial\n        (\n            vec3(1.0,0.0,0.0),  //diffuse color\n            20.0,               //specular amount\n            vec3(1.0,1.0,1.0)   //specular color\n        )\n    );\n\nSAxisAlignedBox floorBox = \n    SAxisAlignedBox\n    (\n        5,                      //Id\n        vec3(0.0,-1.6,0.0),     //center\n        vec3(10.0,0.1,10.0),    //scale\n        SMaterial\n        (\n            vec3(1.0,1.0,1.0),  //diffuse color\n            20.0,               //specular amount\n            vec3(0.0,0.0,0.0)   //specular color\n        )\n    );\n\nSAxisAlignedBox backBox1 = \n    SAxisAlignedBox\n    (\n        6,                      //Id\n        vec3(0.0,0.0,3.0),      //center\n        vec3(10.0,3.0,0.1),     //scale\n        SMaterial\n        (\n            vec3(0.0,0.0,0.8),  //diffuse color\n            20.0,               //specular amount\n            vec3(0.0,0.0,0.0)   //specular color\n        )\n    );\n\nSSphere floorSphere1 =\n    SSphere\n    (\n        7,                      //id\n        vec3(1.5, -1.0, 0.0),   //center\n        0.2,                    //radius\n        SMaterial\n        (\n            vec3(0.8,0.8,0.0),  //diffuse color\n            3.0,                //specular amount\n            vec3(1.0,1.0,1.0)   //specular color\n        )\n    );\n\nSSphere floorSphere2 =\n    SSphere\n    (\n        8,                      //id\n        vec3(1.5, -1.0, 1.0),   //center\n        0.2,                    //radius\n        SMaterial\n        (\n            vec3(0.8,0.8,0.0),  //diffuse color\n            3.0,                //specular amount\n            vec3(1.0,1.0,1.0)   //specular color\n        )\n    );\n\nSSphere floorSphere3 =\n    SSphere\n    (\n        9,                      //id\n        vec3(1.5, -1.0, 2.0),   //center\n        0.2,                    //radius\n        SMaterial\n        (\n            vec3(0.8,0.8,0.0),  //diffuse color\n            3.0,                //specular amount\n            vec3(1.0,1.0,1.0)   //specular color\n        )\n    );\n\n//----- macro lists\n\n// sphere primitive list\n#define SPHEREPRIMLIST PRIM(sphere1) PRIM(sphere2) PRIM(floorSphere1) PRIM(floorSphere2) PRIM(floorSphere3)\n\n// sphere primitive list with light primitives\n#define SPHEREPRIMLISTWITHLIGHTS SPHEREPRIMLIST PRIM(lightPoint1Sphere)\n\n// box primitive list\n#define BOXPRIMLIST PRIM(orbitBox) PRIM(floorBox) PRIM(backBox1)\n\n// point light list\n#define POINTLIGHTLIST LIGHT(lightPoint1)\n\n// directional light list\n#define DIRLIGHTLIST LIGHT(lightDir1)\n\n//=======================================================================================\nbool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n    if (ignorePrimitiveId == sphere.m_Id)\n        return false;\n\n    //get the vector from the center of this circle to where the ray begins.\n    vec3 m = rayPos - sphere.m_center;\n\n    //get the dot product of the above vector and the ray's vector\n    float b = dot(m, rayDir);\n\n    float c = dot(m, m) - sphere.m_radius * sphere.m_radius;\n\n    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n    if(c > 0.0 && b > 0.0)\n        return false;\n\n    //calculate discriminant\n    float discr = b * b - c;\n\n\n    //a negative discriminant corresponds to ray missing sphere\n    if(discr < 0.0)\n        return false;\n\n    //not inside til proven otherwise\n    bool fromInside = false;\n\n    //ray now found to intersect sphere, compute smallest t value of intersection\n    float collisionTime = -b - sqrt(discr);\n\n    //if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n    if(collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        fromInside = true;\n    }\n\n    //enforce a max distance if we should\n    if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)\n        return false;\n\n    // set all the info params since we are garaunteed a hit at this point\n    info.m_fromInside = fromInside;\n    info.m_collisionTime = collisionTime;\n    info.m_material = sphere.m_material;\n\n    //compute the point of intersection\n    info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n    // calculate the normal\n    info.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;\n    info.m_surfaceNormal = normalize(info.m_surfaceNormal);\n\n    // we found a hit!\n    info.m_foundHit = true;\n    info.m_Id = sphere.m_Id;\n    return true;\n}\n\n//=======================================================================================\nbool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n    if (ignorePrimitiveId == box.m_Id)\n        return false;\n    \n    float rayMinTime = 0.0;\n    float rayMaxTime = FLT_MAX;\n    \n    //enforce a max distance\n    if(info.m_collisionTime >= 0.0)\n    {\n        rayMaxTime = info.m_collisionTime;\n    }   \n    \n    // find the intersection of the intersection times of each axis to see if / where the\n    // ray hits.\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        //calculate the min and max of the box on this axis\n        float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;\n        float axisMax = axisMin + box.m_scale[axis];\n\n        //if the ray is paralel with this axis\n        if(abs(rayDir[axis]) < 0.0001)\n        {\n            //if the ray isn't in the box, bail out we know there's no intersection\n            if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)\n                return false;\n        }\n        else\n        {\n            //figure out the intersection times of the ray with the 2 values of this axis\n            float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];\n            float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];\n\n            //make sure min < max\n            if(axisMinTime > axisMaxTime)\n            {\n                float temp = axisMinTime;\n                axisMinTime = axisMaxTime;\n                axisMaxTime = temp;\n            }\n\n            //union this time slice with our running total time slice\n            if(axisMinTime > rayMinTime)\n                rayMinTime = axisMinTime;\n\n            if(axisMaxTime < rayMaxTime)\n                rayMaxTime = axisMaxTime;\n\n            //if our time slice shrinks to below zero of a time window, we don't intersect\n            if(rayMinTime > rayMaxTime)\n                return false;\n        }\n    }\n    \n    //if we got here, we do intersect, return our collision info\n    info.m_fromInside = (rayMinTime == 0.0);\n    if(info.m_fromInside)\n        info.m_collisionTime = rayMaxTime;\n    else\n        info.m_collisionTime = rayMinTime;\n    info.m_material = box.m_material;\n    \n    info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n    // figure out the surface normal by figuring out which axis we are closest to\n    float closestDist = FLT_MAX;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);\n        float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));\n\n        if(distFromEdge < closestDist)\n        {\n            closestDist = distFromEdge;\n            info.m_surfaceNormal = vec3(0.0,0.0,0.0);\n            if(info.m_intersectionPoint[axis] < box.m_pos[axis])\n                info.m_surfaceNormal[axis] = -1.0;\n            else\n                info.m_surfaceNormal[axis] =  1.0;\n        }\n    }\n\n    // we found a hit!\n    info.m_foundHit = true;\n    info.m_Id = box.m_Id;\n    return true;    \n}\n\n//=======================================================================================\nbool PointCanSeePoint(in vec3 startPos, in vec3 targetPos, in int ignorePrimitiveId)\n{\n    // see if we can hit the target point from the starting point\n    SCollisionInfo collisionInfo =\n        SCollisionInfo\n        (\n            0,\n            false,\n            false,\n            -1.0,\n            vec3(0.0,0.0,0.0),\n            vec3(0.0,0.0,0.0),\n            SMaterial(\n                vec3(0.0,0.0,0.0),\n                1.0,\n                vec3(0.0,0.0,0.0)\n            )\n        );  \n    \n    vec3 rayDir = targetPos - startPos;\n    collisionInfo.m_collisionTime = length(rayDir);\n    rayDir = normalize(rayDir);\n\n    // run intersection against all non light primitives. return false on first hit found\n    return true\n    #define PRIM(x) && !RayIntersectSphere(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n    SPHEREPRIMLIST\n    #undef PRIM\n    #define PRIM(x) && !RayIntersectAABox(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n    BOXPRIMLIST\n    #undef PRIM\n    ;\n}\n\n//=======================================================================================\nvoid ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in vec3 rayDir)\n{\n    if (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, light.m_pos, collisionInfo.m_Id))\n    {\n        // diffuse\n        vec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);\n        float dp = dot(collisionInfo.m_surfaceNormal, hitToLight);\n        if(dp > 0.0)\n            pixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;\n                \n        // specular\n        vec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);\n        dp = dot(rayDir, reflection);\n        if (dp > 0.0)\n            pixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;\n    }\n}\n\n//=======================================================================================\nvoid ApplyDirLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SDirLight light, in vec3 rayDir)\n{\n    if (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, collisionInfo.m_intersectionPoint + light.m_reverseDir * 1000.0, collisionInfo.m_Id))\n    {\n        // diffuse\n        float dp = dot(collisionInfo.m_surfaceNormal, light.m_reverseDir);\n        if(dp > 0.0)\n            pixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;\n        \n        // specular\n        vec3 reflection = reflect(light.m_reverseDir, collisionInfo.m_surfaceNormal);\n        dp = dot(rayDir, reflection);\n        if (dp > 0.0)\n            pixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;          \n    }\n}\n\n//=======================================================================================\nfloat DefiniteIntegral (in float x, in float amplitude, in float frequency, in float motionFactor)\n{\n    // Fog density on an axis:\n    // (1 + sin(x*F)) * A\n    //\n    // indefinite integral:\n    // (x - cos(F * x)/F) * A\n    //\n    // ... plus a constant (but when subtracting, the constant disappears)\n    //\n    x += iTime * motionFactor;\n    return (x - cos(frequency * x)/ frequency) * amplitude;\n}\n\n//=======================================================================================\nfloat AreaUnderCurveUnitLength (in float a, in float b, in float amplitude, in float frequency, in float motionFactor)\n{\n    // we calculate the definite integral at a and b and get the area under the curve\n    // but we are only doing it on one axis, so the \"width\" of our area bounding shape is\n    // not correct.  So, we divide it by the length from a to b so that the area is as\n    // if the length is 1 (normalized... also this has the effect of making sure it's positive\n    // so it works from left OR right viewing).  The caller can then multiply the shape\n    // by the actual length of the ray in the fog to \"stretch\" it across the ray like it\n    // really is.\n    return (DefiniteIntegral(a, amplitude, frequency, motionFactor) - DefiniteIntegral(b, amplitude, frequency, motionFactor)) / (a - b);\n}\n\n//=======================================================================================\nfloat FogAmount (in vec3 src, in vec3 dest, in float fogMod)\n{\n    float len = length(dest - src);\n    \n    // calculate base fog amount (constant density over distance)   \n    float amount = len * 0.1;\n    \n    // calculate definite integrals across axes to get moving fog adjustments\n    float adjust = 0.0;\n    adjust += AreaUnderCurveUnitLength(dest.x, src.x, 0.01, 0.6, 2.0);\n    adjust += AreaUnderCurveUnitLength(dest.y, src.y, 0.01, 1.2, 1.4);\n    adjust += AreaUnderCurveUnitLength(dest.z, src.z, 0.01, 0.9, 2.2);\n    adjust *= len;\n    \n    return min(amount+adjust+fogMod, 1.0);\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, in float fogMod)\n{\n    int lastHitPrimitiveId = 0;\n    \n    vec3 rayToCameraDir = rayDir;\n    \n    vec3 pixelColor = vec3(0.0,0.0,0.0);    \n    SCollisionInfo collisionInfo =\n        SCollisionInfo\n        (\n            0,\n            false,\n            false,\n            -1.0,\n            vec3(0.0,0.0,0.0),\n            vec3(0.0,0.0,0.0),\n            SMaterial(\n                vec3(0.0,0.0,0.0),\n                1.0,\n                vec3(0.0,0.0,0.0)\n            )\n        );\n\n    // run intersection against all objects, including light objects        \n    #define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n    SPHEREPRIMLISTWITHLIGHTS\n    #undef PRIM\n            \n    // run intersections against all boxes\n    #define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n    BOXPRIMLIST\n    #undef PRIM\n\n    if (collisionInfo.m_foundHit)\n    {   \n            \n        // do texture sampling for the floorbox\n//        if (collisionInfo.m_Id == floorBox.m_Id)\n//        {\n//            collisionInfo.m_material.m_diffuseColor = \n//            texture2D(iChannel0, collisionInfo.m_intersectionPoint.xz * 0.25).xyz;\n//        }\n            \n        // point lights\n        #define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, rayDir);\n        POINTLIGHTLIST\n        #undef LIGHT\n                \n        // directional lights\n        #define LIGHT(light) ApplyDirLight(pixelColor, collisionInfo, light, rayDir);\n        DIRLIGHTLIST                \n        #undef LIGHT\n\n        // ambient light\n        pixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor;\n                    \n        vec4 fog = vec4(fogColor, FogAmount(rayPos, collisionInfo.m_intersectionPoint, fogMod));\n\n        shadingStack.m_addColor = pixelColor;\n        shadingStack.m_fogColorAndAmount = fog;\n    }\n    // no hit means all fog\n    else\n        shadingStack.m_fogColorAndAmount = vec4(fogColor,1.0);\n}\n\n//=======================================================================================\nvoid main()\n{\n    vec2 rawPercent = (gl_FragCoord.xy / iResolution.xy);\n    vec2 percent = rawPercent - vec2(0.5,0.5);\n    \n    vec3 rayPos;\n    vec3 rayTarget;\n    \n    rayTarget = (cameraFwd * cameraDistance)\n              + (cameraLeft * percent.x * cameraViewWidth)\n              + (cameraUp * percent.y * cameraViewHeight);\n        \n    rayPos = cameraPos;\n    \n    vec3 rayDir = normalize(rayTarget);\n\n    float fogMod = mod( gl_FragCoord.x + gl_FragCoord.y, 2.0 ) / 255.0;\n    \n    TraceRay(rayPos, rayDir, fogMod);\n    \n    vec3 pixelColor = mix(shadingStack.m_addColor, shadingStack.m_fogColorAndAmount.xyz, shadingStack.m_fogColorAndAmount.w);\n\n    gl_FragColor = vec4(pixelColor, 1.0);\n}"}