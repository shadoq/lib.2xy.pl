{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_20283.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"\n#define time iTime * 0.001\n\nconst int MAX_ITER = 8; // Try 30 for extra flames\n\nvec2 rotate(in vec2 v, in float a) {\n    return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nfloat torus(in vec3 p, in vec2 t)\n{\n    vec2 q = abs(vec2(max(abs(p.x), abs(p.z))-t.x, p.y));\n    return max(q.x, q.y)-t.y;\n}\n\n// These are all equally interesting, but I could only pick one :(\nfloat trap(in vec3 p)\n{\n//    float t = time*1e0 + length(surfacePosition)*0.01;\n    float t = time*1e0 + length(p)*0.01;\n    float phase = sin(t)*sin(t);\n    float pseRt = 1./8.;\n    \n    if(phase < pseRt)\n    return abs(max(abs(p.z)-0.1, abs(p.x)-0.1))-0.01;\n    if(phase < pseRt*2.)\n    return length(max(abs(p.xy) - 0.05, 0.0));\n    if(phase < pseRt*3.)\n    return length(p)-0.5;\n    if(phase < pseRt*4.)\n    return length(max(abs(p) - 0.35, 0.0));\n    if(phase < pseRt*5.)\n    return abs(length(p.xz)-0.2)-0.01;\n    if(phase < pseRt*6.)\n    return abs(min(torus(vec3(p.x, mod(p.y,0.4)-0.2, p.z), vec2(0.1, 0.05)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005;\n    if(phase < pseRt*7.)\n    return sin(fract(sin(abs(min(torus(p, cos(time*vec2(0.3, sin(0.034*time)*0.05)*sin(0.23*time))), max(abs(mod(p.z, p.z*sin(0.23*time)))-0.05, abs(p.x)-0.05)))))-0.005);\n    else\n    return min(length(p.xz), min(length(p.yz), length(p.xy))) - 0.05;\n}\n\nfloat map(in vec3 p)\n{\n    float cutout = dot(abs(p.yz),vec2(0.5))-0.035;\n    float road = max(abs(p.y-0.025), abs(p.z)-0.035);\n    \n    vec3 z = abs(1.50-mod(p,3.0));\n    z.yz = rotate(z.yz, time*.025);\n\n    float d = 999.0;\n    float s = .999;\n    for (float i = 0.0; i < 3.0; i++) {\n        z.xz = rotate(z.xz, radians(i*10.0+time));\n        z.zy = rotate(z.yz, radians((i+1.0)*20.0+time*1.1234));\n        z = abs(1.0-mod(z+i/5.,2.3));\n        \n        z = z*2.0 - 0.3;\n        s += sin(time*0.02/time);\n        s *= sin(0.55*sin(time*0.5))+0.523;\n        d = min(d, trap(z) * s);\n    }\n    return min(max(d, -cutout), 2.);\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n    return mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 intersect(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float total_dist = 0.0;\n    vec3 p = rayOrigin;\n    float d = 1.0;\n    float iter = 0.0;\n    float mind = 3.14159+sin(time*10.1)*0.2; // Move road from side to side slowly\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {       \n        if (d < 0.001) continue;\n        \n        d = map(p);\n        // This rotation causes the occasional distortion - like you would see from heat waves\n        p += d*vec3(rayDir.x, rotate(rayDir.yz, sin(mind)));\n        mind = min(mind, d);\n        total_dist += d;\n        iter++;\n    }\n\n    vec3 color = vec3(0.0);\n    if (d < 0.001) {\n        float x = (iter/float(MAX_ITER));\n        float y = (d-0.01)/0.01/(float(MAX_ITER));\n        float z = (0.01-d)/0.01/float(MAX_ITER);\n        if (max(abs(p.y-0.025), abs(p.z)-0.035)<0.002) { // Road\n            float w = smoothstep(mod(p.x*50.0, 4.0), 2.0, 2.01);\n            w -= 1.0-smoothstep(mod(p.x*50.0+2.0, 4.0), 2.0, 1.99);\n            w = fract(w+0.0001);\n            float a = fract(smoothstep(abs(p.z), 0.0025, 0.0026));\n            color = sin(vec3(sin(1.0-x-y*2.)*mix(sin(vec3(0.8, 0.8, 0)), vec3(0.1), sin(1.0-(1.0-w)*(1.0-a)))));\n        } else {\n            float q = 1.0-x-y*1.5+z;\n            color = sin(hsv((iTime*0.002)+sin(q*0.2+0.085), (0.001*time)+.750-q*0.12, q));\n        }\n    } else\n        color = hsv(d, 1.0, 1.0)*mind*45.0; // Background\n    return color;\n}\n\nvoid main()\n{\n    vec3 upDirection = vec3(0, -1, 0);\n    vec3 cameraDir = vec3(3,0,0);\n    vec3 cameraOrigin = vec3(time*90., 0, 0);\n    \n    vec3 u = normalize(cross(upDirection, cameraOrigin));\n    vec3 v = normalize(cross(cameraDir, u));\n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(u * screenPos.x + v * screenPos.y + cameraDir*(1.0-length(screenPos)*0.5));\n    \n    gl_FragColor = vec4(intersect(cameraOrigin, rayDir), 1.0);\n} \n"}