{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:gshadertoy_lss3zn,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"// Insane recursion with multiple effects by Optimus\n// Guest code by AkumaX (rand function)\n\n// Version Zoomer\n\nconst float recursion_level = 8.0;\nfloat time = 0.0;\nvec2 mouse = vec2(0.0);\n\nfloat rand(vec2 vector)\n{\n    return fract( 43758.5453 * sin( dot(vector, vec2(12.9898, 78.233) ) ) );\n}\n\nfloat get_bump_height(vec2 position)\n{\n    return sin((sin(position.x * 32.0) + sin(position.y * 24.0) + sin(position.x * 4.0 + sin(position.y * 8.0 + time))) * 4.0) * 0.5 + 0.5;\n}\n\nfloat get_light(vec2 position)\n{\n    vec2 tex = mod(position * 4.0, 1.0) - vec2(0.5);\n    return 0.0005 / pow(length(tex), 4.0);\n}\n\nvoid main()\n{\n    time = iTime;\n    mouse = vec2(iMouse) * 0.001;\n\n    float scale = cos(time / 2.0) * 8.0 + 8.05;\n    if (scale < 0.025) scale = 0.025;\n\n    vec2 position = vec2((gl_FragCoord.x / iResolution.x) - 0.5, (gl_FragCoord.y / iResolution.y) - 0.5) * scale + mouse * 16.0;\n\n//  vec2 rotated_position;\n//  rotated_position.x = ((position.x - 0.5) * cos(sin(0.25 * iGlobalTime) * 2.5) - (position.y - 0.5) * sin(sin(0.25 * iGlobalTime) * 2.5)) * scale;\n//  rotated_position.y = ((position.y - 0.5) * cos(sin(0.25 * iGlobalTime) * 2.5) + (position.x - 0.5) * sin(sin(0.25 * iGlobalTime) * 2.5)) * scale;\n//  position = rotated_position;\n\n    vec2 coord = mod(position,1.0); // coordinate of single effect window (0.0 - 1.0)\n    vec2 effect = floor(mod(position,4.0)); // effect number (0-3,0-3)\n    float effect_number = effect.y * 4.0 + effect.x;\n    vec2 effect_group = floor(position) * 7.0; // effect group float id\n \n    float gradient = 0.0;\n    vec3 color = vec3(0.0);\n \n    float angle = 0.0;\n    float radius = 0.0;\n    const float pi = 3.141592;\n    float fade = 0.0;\n \n    float u,v;\n    float z;\n \n    vec2 centered_coord = coord - vec2(0.5);\n\n    float dist_from_center = length(centered_coord);\n    float angle_from_center = atan(centered_coord.y, centered_coord.x);\n\n    float iii = 0.0;\n    for (float ii=0.0; ii<=recursion_level; ii++)\n    {\n        if (effect_number==15.0)\n        {\n            position *= 4.0;\n\n            coord = mod(position,1.0);\n            effect = floor(mod(position,4.0));\n            effect_number = effect.y * 4.0 + effect.x;\n            effect_group = floor(position) * 7.0;\n\n            centered_coord = coord - vec2(0.5);\n            dist_from_center = length(centered_coord);\n            angle_from_center = atan(centered_coord.y, centered_coord.x);\n\n            color = vec3(0.5);  \n        } \n        else if (effect_number==0.0)\n        {\n            // gradient = mod(sin(coord.x*400.0) * sin(coord.y * 400.0) * 16.0 * time, 1.0);\n            gradient = (rand( vec2(sin(coord*400.0))*time));\n            color = vec3(gradient);\n            break;\n        }\n        else if (effect_number==1.0)\n        {\n            color.r = sin(coord.x * 32.0) + sin(coord.y * 24.0) + sin(coord.x * 4.0 + sin(coord.y * 8.0 + time));\n            color.g = sin(coord.x * 16.0) + sin(coord.y * 12.0) + sin(coord.x * 8.0 + sin(coord.y * 16.0 + 2.0 * time));\n            color.b = sin(coord.x * 8.0) + sin(coord.y * 48.0) + sin(coord.x * 2.0 + sin(coord.y * 4.0 + 3.0 * time));\n            break;\n        }\n        else if (effect_number==2.0)\n        {\n            radius = dist_from_center + sin(iTime * 8.0) * 0.1 + 0.1;\n            angle = angle_from_center + time;\n     \n            gradient = 0.5 / radius + sin(angle * 5.0) * 0.3;\n            color = vec3(gradient, gradient / 2.0, gradient / 3.0);\n            break;\n        }\n        else if (effect_number==3.0)\n        {\n            radius = dist_from_center;\n            angle = angle_from_center + time;\n     \n            gradient = sin(mod(angle + sin(-radius + time) * 2.0,2.0*pi) * 4.0) + 1.0;\n            color = vec3(gradient/3.0, gradient / 2.0, gradient);\n            break;\n        }\n        else if (effect_number==4.0)\n        {\n            float dist_from_center_y = length(centered_coord.y);\n            u = 8.0/dist_from_center_y + 16.0*iTime;\n            v = (16.0/dist_from_center_y)* centered_coord.x + sin(iTime) * 8.0;\n     \n            fade = dist_from_center_y * 2.0;\n            gradient = ((1.0 - pow(sin(u) + 1.0, 0.1)) + (1.0 - pow(sin(v) + 1.0, 0.1))) * fade;\n            color = vec3(gradient / 2.0, gradient, gradient / 2.0);\n            break;\n        }\n        else if (effect_number==5.0)\n        {\n            u = 8.0 / dist_from_center + 16.0 * iTime;\n            v = angle_from_center * 16.0;\n     \n            fade = dist_from_center * 2.0;\n            gradient = ((1.0 - pow(sin(u) + 1.0, 0.1)) + (1.0 - pow(sin(v) + 1.0, 0.1))) * fade;\n            color = vec3(gradient * 4.0, gradient, gradient / 2.0);\n            break;\n        }\n        else if (effect_number==6.0)\n        {\n            for (float i=0.0; i<=32.0; i++)\n            {\n                vec2 blob_coord = vec2(sin(2.0*i + 2.0*iTime) * 0.4, cos(3.0*i + 3.0 * iTime) * 0.4);\n                gradient += ((0.0001 + sin(i*i + 4.0*iTime) * 0.000095)) / pow(length(centered_coord - blob_coord), 2.75);\n            }\n            color = vec3(gradient, gradient * 2.0, gradient / 2.0);\n        }\n        else if (effect_number==7.0)\n        {\n            gradient = 1.0;\n            for (float i=0.0; i<=16.0; i++)\n            {\n                vec2 blob_coord = vec2(sin(32.0*i + 0.5*iTime) * 0.5, cos(256.0*i + 1.0 * time) * 0.5);\n                gradient = min(gradient, length(centered_coord - blob_coord));\n            }\n            gradient = pow(sin(gradient), 2.0) * 16.0;\n            color = vec3(gradient / 1.5, gradient / 2.0, gradient * 1.5);\n            break;\n        }\n        else if (effect_number==8.0)\n        {\n            float disp = 0.005;\n            float p00 = get_bump_height(centered_coord);\n            float p10 = get_bump_height(centered_coord + vec2(disp, 0.0));\n            float p01 = get_bump_height(centered_coord + vec2(0.0, disp));\n     \n            float dx = p10 - p00;\n            float dy = p01 - p00;\n     \n            vec2 light_coord = vec2(sin(iTime) * 0.3, sin(2.0*iTime) * 0.3);\n            vec2 disp_coord = centered_coord - vec2(dx, dy);\n            gradient = 0.1 / length(disp_coord - light_coord);\n            color = vec3(gradient, gradient, gradient * 1.25);\n            break;\n        }\n        else if (effect_number==9.0)\n        {\n            vec2 rotated_coord;\n            float zoom = sin(iTime) + 1.25;\n            rotated_coord.x = zoom * (centered_coord.x * cos(iTime) - centered_coord.y * sin(iTime));\n            rotated_coord.y = zoom * (centered_coord.y * cos(iTime) + centered_coord.x * sin(iTime));\n    \n            vec2 pix = floor(rotated_coord * 8.0);\n    \n            gradient = mod(mod(pix.x,2.0) + mod(pix.y,2.0),2.0);\n            color = vec3(gradient);\n    \n            float raster1 = 0.01 / length(centered_coord.y - sin(1.5 * iTime) * 0.5);\n            float raster2 = 0.01 / length(centered_coord.y - sin(1.5 * iTime + 0.3) * 0.5);\n            float raster3 = 0.01 / length(centered_coord.y - sin(1.5 * iTime + 0.6) * 0.5);\n            vec3 rcolor;\n            if (raster1 > 0.25 || raster2 > 0.25 || raster3 > 0.25)\n            {\n                rcolor = vec3(raster1, 0.0, 0.0);\n                rcolor += vec3(0.0, raster2, 0.0);\n                rcolor += vec3(0.0, 0.0, raster3);\n                color = rcolor;\n            }\n            break;\n        }\n        else if (effect_number==10.0)\n        {\n            for (float i=1.0; i<=128.0; i++)\n            {\n                vec2 star_pos = vec2(sin(i) * 64.0, sin(i*i*i) * 64.0);\n                float z = mod(i*i - 128.0*iTime, 256.0);\n                float fade = (256.0 - z) / 256.0;\n                vec2 blob_coord = star_pos / z;\n                gradient += ((fade / 384.0) / pow(length(centered_coord - blob_coord), 1.5)) * (fade * fade);\n            }\n    \n            color = vec3(gradient * 2.0, gradient, gradient / 2.0);\n            break;\n        }\n        else if (effect_number==11.0)\n        {\n            float z = sqrt(0.25 - centered_coord.x * centered_coord.x - centered_coord.y * centered_coord.y);\n            vec2 tex = (centered_coord * 32.0) / z;\n     \n            fade = pow(z,2.0);\n            vec2 discolamp = vec2(pow(sin(tex.x + sin(0.5 * iTime) * 64.0) + 1.0, 2.0), pow(sin(tex.y + sin(0.4 * iTime) * 128.0) + 1.0, 2.0));\n            gradient = (4.0 - discolamp.x - discolamp.y) * fade;\n            color = vec3(gradient * 4.0, gradient, gradient / 2.0);\n            break;\n        }\n        else if (effect_number==12.0)\n        {\n            const float steps = 64.0;\n            float sum = 0.0;\n            for (float i=0.0; i<=steps; i++)\n            {\n                vec2 light_coord = centered_coord + vec2(sin(iTime), sin(iTime * 1.24));\n                vec2 displacement = vec2(mix(centered_coord, 0.25 * light_coord, (steps - i) / steps));\n                sum = mix(get_light(centered_coord + displacement), sum, 0.9);\n            }\n            gradient = sum;\n    if (gradient <= 0.1) gradient = length(centered_coord) * 0.25;\n            color = vec3(gradient * 4.0, gradient, gradient / 2.0);\n            break;\n        }\n        else if (effect_number==13.0)\n        {\n            float xpos = -0.5 + sin(centered_coord.y * 16.0 + iTime) * 0.06;\n            float ypos = 0.0 + sin(centered_coord.x * 24.0 + 1.5 * iTime) * 0.04;\n            const float z_fractal = 0.4;\n    \n            const float iter = 64.0;\n            const float iter2 = iter / 4.0;\n        \n            float z0_r = 0.0;\n            float z0_i = 0.0;\n            float z1_r = 0.0;\n            float z1_i = 0.0;\n            float p_r = (centered_coord.x + xpos * z_fractal) / z_fractal;\n            float p_i = (centered_coord.y + ypos * z_fractal) / z_fractal;\n            float d = 0.0;\n        \n            float nn;\n            for (float n=0.0; n<=iter; n++)\n            {\n                z1_r = z0_r * z0_r - z0_i * z0_i + p_r;\n                z1_i = 2.0 * z0_r * z0_i + p_i;\n                d = sqrt(z1_i * z1_i + z1_r * z1_r);\n                z0_r = z1_r;\n                z0_i = z1_i;\n                if (d > iter2) break;\n                nn = n;\n            }\n        \n            gradient = (nn / iter) * 4.0;\n        \n            color = vec3(gradient * 2.0, gradient, gradient * 16.0);\n            break;\n        }\n        else if (effect_number==14.0)\n        {\n            float zom = 3.5;\n            float x0 = centered_coord.x * zom;\n            float y0 = centered_coord.y * zom;\n    \n            float x1, y1, mj2;\n            const float iter = 32.0;\n    \n            float posx = sin(iTime * 2.0) * 0.75;\n            float posy = sin(iTime * 1.5) * 0.75;\n    \n            float nn;\n            for (float n=0.0; n<=iter; n++)\n            {\n                x1 = x0*x0 - y0*y0 + posx;\n                y1 = 2.0*x0*y0 + posy;\n                mj2 = x1*x1 + y1*y1;\n                x0 = x1; y0 = y1;\n                nn = n;\n                if (mj2 > iter) break;\n            }\n    \n            gradient = (nn / iter) * 2.0;\n    \n            color = vec3(1.0 - gradient, 1.0 - gradient * 2.0, gradient * 2.0);\n        }\n        iii = ii;\n    }\n \n    color.r *= (sin(effect_group.x * (iii+1.0)) * 0.5 + 0.5);\n    color.g *= (sin(effect_group.x + effect_group.y * (iii*iii*iii)) * 0.5 + 0.5);\n    color.b *= (sin(effect_group.x * effect_group.y* (iii*iii+1.5)) * 0.5 + 0.5);\n \n    gl_FragColor = vec4(color, 1.0 );\n}\n"}