{class:mobi.shad.s3lib.gfx.g3d.shaders.SimpleShader$ShaderData,name:glsl_1554.0,type:null,id:null,date:null,author:null,description:null,tags:null,color:false,normal:false,textures:0,vertex:"void main(){\n\tgl_Position = projectionMatrix * modelViewMatrix * a_position;\n}",fragment:"\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n\nfloat halfpi = asin(1.); // AMD/OSX fix\nfloat cos(float v){\n    return sin( v + halfpi);\n}\n\n// minecraft flickers!\n// warped by weylandyutani amsterdam 2012\n    \n// (Kabuto) made this a bit more minecraft-like ;-) speed-optimized by selectively both blob-based and voxel-based raymarching\n\n// Start simplex noise\n\n    //\n    // Description : Array and textureless GLSL 2D/3D/4D simplex\n    // noise functions.\n    // Author : Ian McEwan, Ashima Arts.\n    // Maintainer : ijm\n    // Lastmod : 20110822 (ijm)\n    // License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    // Distributed under the MIT License. See LICENSE file.\n    // https://github.com/ashima/webgl-noise\n    //\n    // Modified by Kabuto to return the derivative as well\n    //\n    \n    \n    vec4 permute(vec4 x) {\n         return mod(((x*34.0)+1.0)*x, 289.0);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    // modified perlin noise, giving value in w and derivative in xyz\n    float snoise(vec3 v)\n      {\n      const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n    // First corner\n      vec3 i = floor(v + dot(v, C.yyy) );\n      vec3 x0 = v - i + dot(i, C.xxx) ;\n    \n    // Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n    \n      // x0 = x0 - 0.0 + 0.0 * C.xxx;\n      // x1 = x0 - i1 + 1.0 * C.xxx;\n      // x2 = x0 - i2 + 2.0 * C.xxx;\n      // x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n      vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n    \n    // Permutations\n      i = mod(i,289.0);\n      vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; // 1.0/7.0\n      vec3 ns = n_ * D.wyz - D.xzx;\n    \n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n    \n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n    \n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n    \n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n    \n      //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n    \n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n    \n    //Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n    \n    // Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n     return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n          \n    // derivatives\n     /* vec3 dx = vec3(0.001, 0, 0);\n      vec4 mx = max(0.6 - vec4(dot(x0+dx,x0+dx), dot(x1+dx,x1+dx), dot(x2+dx,x2+dx), dot(x3+dx,x3+dx)), 0.0);\n      mx = mx * mx;\n      float wx = 42.0 * dot( mx*mx, vec4( dot(p0,x0+dx), dot(p1,x1+dx), dot(p2,x2+dx), dot(p3,x3+dx) ) );\n\n      vec3 dy = vec3(0, 0.001, 0);\n      vec4 my = max(0.6 - vec4(dot(x0+dy,x0+dy), dot(x1+dy,x1+dy), dot(x2+dy,x2+dy), dot(x3+dy,x3+dy)), 0.0);\n      my = my * my;\n      float wy = 42.0 * dot( my*my, vec4( dot(p0,x0+dy), dot(p1,x1+dy), dot(p2,x2+dy), dot(p3,x3+dy) ) );\n\n      vec3 dz = vec3(0, 0, 0.001);\n      vec4 mz = max(0.6 - vec4(dot(x0+dz,x0+dz), dot(x1+dz,x1+dz), dot(x2+dz,x2+dz), dot(x3+dz,x3+dz)), 0.0);\n      mz = mz * mz;\n      float wz = 42.0 * dot( mz*mz, vec4( dot(p0,x0+dz), dot(p1,x1+dz), dot(p2,x2+dz), dot(p3,x3+dz) ) );\n          \n    return vec4((wx-w)*100.0, (wy-w)*100.0, (wz-w)*100.0, w);*/\n      }\n\n// End simplex noise\n    \n#define pi 6.1415\n//Landscape\n    \nfloat random(vec4 seed)\n{\n    return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)) + dot(seed.zw ,vec2(15.2472,93.2541))) * 43758.5453);\n}\n\nfloat floorTo(float value, float factor)\n{\n    return floor(value / factor) * factor;\n}\n\nvec2 floorTo(vec2 value, vec2 factor)\n{\n    return vec2(floorTo(value.x, factor.x), floorTo(value.y, factor.y));\n}\n\nfloat lerp(float x, float X, float amount, bool usecos)\n{\n     if(usecos)\n     {\n        return x + (X - x) * ((cos(amount * pi) - 1.0 ) / -2.0);\n     }\n     else\n     {\n        return x + (X - x) * amount;\n     }\n}\n\nfloat bilerp(float xy, float Xy, float xY, float XY, vec2 amount, bool usecos)\n{\n    float x = lerp(xy, xY, amount.y, usecos);\n    float X = lerp(Xy, XY, amount.y, usecos);\n    return lerp(x, X, amount.x, usecos);\n}\n\nfloat getBilerp(vec2 position, vec2 size, float seed, bool usecos)\n{\n    vec2 min = floorTo(position, size);\n    vec2 max = min + size;\n \n    return bilerp(random(vec4(min.x, min.y, seed, seed)),\n        random(vec4(max.x, min.y, seed, seed)),\n        random(vec4(min.x, max.y, seed, seed)),\n        random(vec4(max.x, max.y, seed, seed)),\n        (position - min) / size, usecos);\n}\n\nvec2 getTunnelCoords(float z) {\n    return vec2(cos(z*0.03)*6.0 + cos(z*0.023)*12.0, cos(z*0.02)*6.0);\n}\n\n// > 0 -> void, < 0 -> solid. if > 0 it should be the approximate distance to nearest solid.\nfloat ShouldDraw(vec3 voxel)\n{   \n    vec2 tunnel = getTunnelCoords(voxel.z);\n    float tx = voxel.x - tunnel.x;\n    float ty = voxel.y - tunnel.y;\n    return max(2.-sqrt(tx*tx+ty*ty), (5. + ty*.4 + snoise(voxel*.03)*5. - 1. + snoise(voxel*.01)*12.));\n}\n\n//currently returns one of 4 stone types\nfloat getStoneType(vec3 voxel) {\n    float s1 = snoise(voxel*.01);\n    float s2 = snoise(voxel*.007);\n    return mix(sign(s1)*.5+2.5, sign(s2)*.5+.5, step(abs(s1*.2),abs(s2)));\n}\n\n\nvoid IterateVoxel(inout vec3 voxel, Ray ray, out vec3 hitPoint, out vec3 actual)\n{   \n    vec3 stp = voxel + step(vec3(0), ray.Direction) - ray.Origin;\n    vec3 max = stp / ray.Direction;\n    \n    if(max.x < min(max.y, max.z)) {\n        voxel.x += sign(ray.Direction.x);\n        hitPoint = vec3(1,0,0);\n        actual = stp.x/ray.Direction.x*ray.Direction + ray.Origin;\n    } else if(max.y < max.z) {\n        voxel.y += sign(ray.Direction.y);\n        hitPoint = vec3(0,1,0);\n        actual = stp.y/ray.Direction.y*ray.Direction + ray.Origin;\n    } else {\n        voxel.z += sign(ray.Direction.z);\n        hitPoint = vec3(0,0,1);\n        actual = stp.z/ray.Direction.z*ray.Direction + ray.Origin;\n    }\n}\n    \nvec4 getColorAt(vec3 voxel, vec3 actual, vec3 hitPoint, Ray ray) {\n    const float lightDist = 55.0;\n    float lightNum = voxel.z/lightDist+1e-5;\n    float lightFrac = fract(lightNum);\n    lightNum -= lightFrac;\n    float lightZ = lightNum*lightDist;\n    vec3 light = vec3(getTunnelCoords(lightZ), lightZ);\n    vec3 lv = light-voxel;\n    float lvl = length(lv);\n    float light2 =( dot( hitPoint, lv )/lvl+1.2) / (lvl*lvl);\n    float totallight = light2*(1.-lightFrac);\n    \n    lightNum += 1.;\n    lightZ += lightDist;\n    light = vec3(getTunnelCoords(lightZ), lightZ);\n    lv = light-voxel;\n    lvl = length(lv);\n    light2 =( dot( hitPoint, lv )/lvl+1.2) / (lvl*lvl);\n    totallight += light2*lightFrac;\n    totallight *= 103.;\n    totallight += dot(hitPoint*sign(ray.Direction),vec3(0,-1,0))*0.2+0.2 ;\n    \n    vec2 tex = floor(fract(vec2(dot(hitPoint,actual.zxx),dot(hitPoint,actual.yzy)))*16.);\n    \n    float stone = getStoneType(voxel)+1.;\n    \n    vec3 c0 = vec3(0.7+stone*.1,0.7,0.7-stone*.1);\n    vec3 c1 = vec3(0.7,0.7,0.7)+vec3(stone-3.5,3.5-stone,-0.3)*step(2.5,stone);\n    \n    \n    float rnd = dot(sin(tex*vec2(3.3-stone*.7,.01+.3*stone)), sin(tex*vec2(3.1+stone,.01+.3*stone)));\n    vec3 rndV = max(0.,rnd)*c0+max(0.,-rnd)*c1;\n    \n    if (stone == 1. && ShouldDraw(voxel+vec3(0,1,0)) > 0. && actual.y-voxel.y > 0.7) {\n        return vec4((vec3(0.1,0.5,0.1)+rndV*.3)*totallight, 1.);\n    } else if (stone == 1. && ShouldDraw(voxel+vec3(0,3,0)) > 0.) {\n        return vec4((vec3(0.6,0.3,0.0)+rndV*.3)*totallight, 1.);\n    }\n    \n    return sqrt(vec4(1.,.8,iTime*1e-10+.6+1e-10*iTime/20.0,1.)*vec4(rndV,1.)*totallight);\n}\n    \n\nvec4 GetRayColor(Ray ray)\n{\n    vec3 voxel = ray.Origin - fract(ray.Origin);\n    vec3 hitPoint;\n    vec3 actual;\n    \n    const int maxIter = 250;/*CAREFUL WITH THIS!!!*/\n    \n    for(int i=0;i<maxIter;i++)\n    {\n        float dist = ShouldDraw(voxel);\n        if(dist < 0. || i == maxIter-1) {\n            return getColorAt(voxel, actual, hitPoint, ray);\n        } else if (voxel.y > 20.) {\n            return vec4(0.3, 0.6, 0.9, 0.0);\n        } else if (dist < 3.) {\n            IterateVoxel(voxel, ray, hitPoint, actual);\n        }\n        else {\n            voxel = ray.Origin + ray.Direction * (dot(voxel + .5 - ray.Origin, ray.Direction)+dist-1.);\n            voxel = floor(voxel);\n        }\n    }\n    \n    return vec4(0);\n}\n\nvoid GetCameraRay(const in vec3 position, const in vec3 lookAt, out Ray currentRay)\n{\n    vec3 forwards = normalize(lookAt - position);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \n    \n    vec2 uV = ( gl_FragCoord.xy / iResolution.xy );\n    vec2 viewCoord = uV * 2.0 - 1.0;\n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    viewCoord.y /= ratio;                              \n    \n    currentRay.Origin = position;\n    \n    vec3 right = normalize(cross(forwards, worldUp));\n    vec3 up = cross(right, forwards);\n           \n    currentRay.Direction = normalize( right * viewCoord.x + up * viewCoord.y + forwards);\n}\n\nvoid main( void ) \n{\n    Ray currentRay;\n \n    float time2 = iTime*15.;\n    GetCameraRay(vec3(getTunnelCoords(time2),time2), vec3(0.1, 0.0, time2*1.+17.), currentRay);\n\n    //making black \"black\" instead of alpha black... _gtoledo3\n    gl_FragColor = vec4(vec3(GetRayColor(currentRay)),1.0);\n}"}